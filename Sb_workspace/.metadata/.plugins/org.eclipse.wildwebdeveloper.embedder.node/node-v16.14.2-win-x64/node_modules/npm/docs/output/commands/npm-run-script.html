---
title: package.json
section: 5
description: Specifics of npm's package.json handling
---

### Description

This document is all you need to know about what's required in your
package.json file.  It must be actual JSON, not just a JavaScript object
literal.

A lot of the behavior described in this document is affected by the config
settings described in [`config`](/using-npm/config).

### name

If you plan to publish your package, the *most* important things in your
package.json are the name and version fields as they will be required. The
name and version together form an identifier that is assumed to be
completely unique.  Changes to the package should come along with changes
to the version. If you don't plan to publish your package, the name and
version fields are optional.

The name is what your thing is called.

Some rules:

* The name must be less than or equal to 214 characters. This includes the
  scope for scoped packages.
* The names of scoped packages can begin with a dot or an underscore. This
  is not permitted without a scope.
* New packages must not have uppercase letters in the name.
* The name ends up being part of a URL, an argument on the command line,
  and a folder name. Therefore, the name can't contain any non-URL-safe
  characters.

Some tips:

* Don't use the same name as a core Node module.
* Don't put "js" or "node" in the name.  It's assumed that it's js, since
  you're writing a package.json file, and you can specify the engine using
  the "engines" field.  (See below.)
* The name will probably be passed as an argument to require(), so it
  should be something short, but also reasonably descriptive.
* You may want to check the npm registry to see if there's something by
  that name already, before you get too attached to it.
  <https://www.npmjs.com/>

A name can be optionally prefixed by a scope, e.g. `@myorg/mypackage`. See
[`scope`](/using-npm/scope) for more detail.

### version

If you plan to publish your package, the *most* important things in your
package.json are the name and version fields as they will be required. The
name and version together form an identifier that is assumed to be
completely unique.  Changes to the package should come along with changes
to the version. If you don't plan to publish your package, the name and
version fields are optional.

Version must be parseable by
[node-semver](https://github.com/npm/node-semver), which is bundled with
npm as a dependency.  (`npm install semver` to use it yourself.)

### description

Put a description in it.  It's a string.  This helps people discover your
package, as it's listed in `npm search`.

### keywords

Put keywords in it.  It's an array of strings.  This helps people discover
your package as it's listed in `npm search`.

### homepage

The url to the project homepage.

Example:

```json
"homepage": "https://github.com/owner/project#readme"
```

### bugs

The url to your project's issue tracker and / or the email address to which
issues should be reported. These are helpful for people who encounter
issues with your package.

It should look like this:

```json
{
  "url" : "https://github.com/owner/project/issues",
  "email" : "project@hostname.com"
}
```

You can specify either one or both values. If you want to provide only a
url, you can specify the value for "bugs" as a simple string instead of an
object.

If a url is provided, it will be used by the `npm bugs` command.

### license

You should specify a license for your package so that people know how they
are permitted to use it, and any restrictions you're placing on it.

If you're using a common license such as BSD-2-Clause or MIT, add a current
SPDX license identifier for the license you're using, like this:

```json
{
  "license" : "BSD-3-Clause"
}
```

You can check [the full list of SPDX license
IDs](https://spdx.org/licenses/).  Ideally you should pick one that is
[OSI](https://opensource.org/licenses/alphabetical) approved.

If your package is licensed under multiple common licenses, use an [SPDX
license expression syntax version 2.0
string](https://www.npmjs.com/package/spdx), like this:

```json
{
  "license" : "(ISC OR GPL-3.0)"
}
```
If you are using a license that hasn't been assigned an SPDX identifier, or if
you are using a custom license, use a string value like this one:

```json
{
  "license" : "SEE LICENSE IN <filename>"
}
```
Then include a file named `<filename>` at the top level of the package.

Some old packages used license objects or a "licenses" property containing
an array of license objects:

```json
// Not valid metadata
{
  "license" : {
    "type" : "ISC",
    "url" : "https://opensource.org/licenses/ISC"
  }
}

// Not valid metadata
{
  "licenses" : [
    {
      "type": "MIT",
      "url": "https://www.opensource.org/licenses/mit-license.php"
    },
    {
      "type": "Apache-2.0",
      "url": "https://opensource.org/licenses/apache2.0.php"
    }
  ]
}
```

Those styles are now deprecated. Instead, use SPDX expressions, like this:

```json
{
  "license": "ISC"
}
```

```json
{
  "license": "(MIT OR Apache-2.0)"
}
```

Finally, if you do not wish to grant others the right to use a private or
unpublished package under any terms:

```json
{
  "license": "UNLICENSED"
}
```

Consider also setting `"private": true` to prevent accidental publication.

### people fields: author, contributors

The "author" is one person.  "contributors" is an array of people.  A
"person" is an object with a "name" field and optionally "url" and "email",
like this:

```json
{
  "name" : "Barney Rubble",
  "email" : "b@rubble.com",
  "url" : "http://barnyrubble.tumblr.com/"
}
```

Or you can shorten that all into a single string, and npm will parse it for
you:

```json
{
  "author": "Barney Rubble <b@rubble.com> (http://barnyrubble.tumblr.com/)"
}
```

Both email and url are optional either way.

npm also sets a top-level "maintainers" field with your npm user info.

### funding

You can specify an object containing an URL that provides up-to-date
information about ways to help fund development of your package, or a
string URL, or an array of these:

```json
{
  "funding": {
    "type" : "individual",
    "url" : "http://example.com/donate"
  },

  "funding": {
    "type" : "patreon",
    "url" : "https://www.patreon.com/my-account"
  },

  "funding": "http://example.com/donate",

  "funding": [
    {
      "type" : "individual",
      "url" : "http://example.com/donate"
    },
    "http://example.com/donateAlso",
    {
      "type" : "patreon",
      "url" : "https://www.patreon.com/my-account"
    }
  ]
}
```

Users can use the `npm fund` subcommand to list the `funding` URLs of all
dependencies of their project, direct and indirect. A shortcut to visit
each funding url is also available when providing the project name such as:
`npm fund <projectname>` (when there are multiple URLs, the first one will
be visited)

### files

The optional `files` field is an array of file patterns that describes the
entries to be included when your package is installed as a dependency. File
patterns follow a similar syntax to `.gitignore`, but reversed: including a
file, directory, or glob pattern (`*`, `**/*`, and such) will make it so
that file is included in the tarball when it's packed. Omitting the field
will make it default to `["*"]`, which means it will include all files.

Some special files and directories are also included or excluded regardless
of whether they exist in the `files` array (see below).

You can also provide a `.npmignore` file in the root of your package or in
subdirectories, which will keep files from being included. At the root of
your package it will not override the "files" field, but in subdirectories
it will. The `.npmignore` file works just like a `.gitignore`. If there is
a `.gitignore` file, and `.npmignore` is missing, `.gitignore`'s contents
will be used instead.

Files included with the "package.json#files" field _cannot_ be excluded
through `.npmignore` or `.gitignore`.

Certain files are always included, regardless of settings:

* `package.json`
* `README`
* `LICENSE` / `LICENCE`
* The file in the "main" field

`README` & `LICENSE` can have any case and extension.

Conversely, some files are always ignored:

* `.git`
* `CVS`
* `.svn`
* `.hg`
* `.lock-wscript`
* `.wafpickle-N`
* `.*.swp`
* `.DS_Store`
* `._*`
* `npm-debug.log`
* `.npmrc`
* `node_modules`
* `config.gypi`
* `*.orig`
* `package-lock.json` (use
  [`npm-shrinkwrap.json`](/configuring-npm/npm-shrinkwrap-json) if you wish
  it to be published)

### main

The main field is a module ID that is the primary entry point to your
program.  That is, if your package is named `foo`, and a user installs it,
and then does `require("foo")`, then your main module's exports object will
be returned.

This should be a module relative to the root of your package folder.

For most modules, it makes the most sense to have a main script and often
not much else.

If `main` is not set it defaults to `index.js` in the packages root folder.

### browser

If your module is meant to be used client-side the browser field should be
used instead of the main field. This is helpful to hint users that it might
rely on primitives that aren't available in Node.js modules. (e.g.
`window`)

### bin

A lot of packages have one or more executable files that they'd like to
install into the PATH. npm makes this pretty easy (in fact, it uses this
feature to install the "npm" executable.)

To use this, supply a `bin` field in your package.json which is a map of
command name to local file name. When this package is installed
globally, that file will be linked where global bins go so it is
available to run by name.  When this package is installed as a
dependency in another package, the file will be linked where it will be
available to that package either directly by `npm exec` or by name in other
scripts when invoking them via `npm run-script`.


For example, myapp could have this:

```json
{
  "bin": {
    "myapp": "./cli.js"
  }
}
```

So, when you install myapp, it'll create a symlink from the `cli.js` script
to `/usr/local/bin/myapp`.

If you have a single executable, and its name should be the name of the
package, then you can just supply it as a string.  For example:

```json
{
  "name": "my-program",
  "version": "1.2.5",
  "bin": "./path/to/program"
}
```

would be the same as this:

```json
{
  "name": "my-program",
  "version": "1.2.5",
  "bin": {
    "my-program": "./path/to/program"
  }
}
```

Please make sure that your file(s) referenced in `bin` starts with
`#!/usr/bin/env node`, otherwise the scripts are started without the node
executable!

Note that you can also set the executable files using [directories.bin](#directoriesbin).

See [folders](/configuring-npm/folders#executables) for more info on
executables.

### man

Specify either a single file or an array of filenames to put in place for
the `man` program to find.

If only a single file is provided, then it's installed such that it is the
result from `man <pkgname>`, regardless of its actual filename.  For
example:

```json
{
  "name": "foo",
  "version": "1.2.3",
  "description": "A packaged foo fooer for fooing foos",
  "main": "foo.js",
  "man": "./man/doc.1"
}
```

would link the `./man/doc.1` file in such that it is the target for `man
foo`

If the filename doesn't start with the package name, then it's prefixed.
So, this:

```json
{
  "name": "foo",
  "version": "1.2.3",
  "description": "A packaged foo fooer for fooing foos",
  "main": "foo.js",
  "man": [
    "./man/foo.1",
    "./man/bar.1"
  ]
}
```

will create files to do `man foo` and `man foo-bar`.

Man files must end with a number, and optionally a `.gz` suffix if they are
compressed.  The number dictates which man section the file is installed
into.

```json
{
  "name": "foo",
  "version": "1.2.3",
  "description": "A packaged foo fooer for fooing foos",
  "main": "foo.js",
  "man": [
    "./man/foo.1",
    "./man/foo.2"
  ]
}
```

will create entries for `man foo` and `man 2 foo`

### directories

The CommonJS [Packages](http://wiki.commonjs.org/wiki/Packages/1.0) spec
details a few ways that you can indicate the structure of your package
using a `directories` object. If you look at [npm's
package.json](https://registry.npmjs.org/npm/latest), you'll see that it
has directories for doc, lib, and man.

In the future, this information may be used in other creative ways.

#### directories.bin

If you specify a `bin` directory in `directories.bin`, all the files in
that folder will be added.

Because of the way the `bin` directive works, specifying both a `bin` path
and setting `directories.bin` is an error. If you want to specify
individual files, use `bin`, and for all the files in an existing `bin`
directory, use `directories.bin`.

#### directories.man

A folder that is full of man pages.  Sugar to generate a "man" array by
walking the folder.

### repository

Specify the place where your code lives. This is helpful for people who
want to contribute.  If the git repo is on GitHub, then the `npm docs`
command will be able to find you.

Do it like this:

```json
{
  "repository": {
    "type": "git",
    "url": "https://github.com/npm/cli.git"
  }
}
```

The URL should be a publicly available (perhaps re