rts__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "main": () => (/* binding */ main),
/* harmony export */   "runMain": () => (/* binding */ runMain)
/* harmony export */ });
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! clipanion */ "./.yarn/__virtual__/clipanion-virtual-119dc92083/0/cache/clipanion-npm-3.0.1-901533eeed-3a4b0c1e7d.zip/node_modules/clipanion/lib/advanced/index.js");
/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Engine */ "./sources/Engine.ts");
/* harmony import */ var _commands_Disable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./commands/Disable */ "./sources/commands/Disable.ts");
/* harmony import */ var _commands_Enable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commands/Enable */ "./sources/commands/Enable.ts");
/* harmony import */ var _commands_Hydrate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commands/Hydrate */ "./sources/commands/Hydrate.ts");
/* harmony import */ var _commands_Prepare__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./commands/Prepare */ "./sources/commands/Prepare.ts");
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./miscUtils */ "./sources/miscUtils.ts");
/* harmony import */ var _corepackUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./corepackUtils */ "./sources/corepackUtils.ts");
/* harmony import */ var _specUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./specUtils */ "./sources/specUtils.ts");









function getPackageManagerRequestFromCli(parameter, context) {
    if (!parameter)
        return null;
    const match = parameter.match(/^([^@]*)(?:@(.*))?$/);
    if (!match)
        return null;
    const [, binaryName, binaryVersion] = match;
    const packageManager = context.engine.getPackageManagerFor(binaryName);
    if (!packageManager)
        return null;
    return {
        packageManager,
        binaryName,
        binaryVersion: binaryVersion || null,
    };
}
async function executePackageManagerRequest({ packageManager, binaryName, binaryVersion }, args, context) {
    var _a;
    const defaultVersion = await context.engine.getDefaultVersion(packageManager);
    const definition = context.engine.config.definitions[packageManager];
    // If all leading segments match one of the patterns defined in the `transparent`
    // key, we tolerate calling this binary even if the local project isn't explicitly
    // configured for it, and we use the special default version if requested.
    let isTransparentCommand = false;
    for (const transparentPath of definition.transparent.commands) {
        if (transparentPath[0] === binaryName && transparentPath.slice(1).every((segment, index) => segment === args[index])) {
            isTransparentCommand = true;
            break;
        }
    }
    const fallbackReference = isTransparentCommand
        ? (_a = definition.transparent.default) !== null && _a !== void 0 ? _a : defaultVersion
        : defaultVersion;
    const fallbackLocator = {
        name: packageManager,
        reference: fallbackReference,
    };
    let descriptor;
    try {
        descriptor = await _specUtils__WEBPACK_IMPORTED_MODULE_7__.findProjectSpec(context.cwd, fallbackLocator, { transparent: isTransparentCommand });
    }
    catch (err) {
        if (err instanceof _miscUtils__WEBPACK_IMPORTED_MODULE_5__.Cancellation) {
            return 1;
        }
        else {
            throw err;
        }
    }
    if (binaryVersion)
        descriptor.range = binaryVersion;
    const resolved = await context.engine.resolveDescriptor(descriptor, { allowTags: true });
    if (resolved === null)
        throw new clipanion__WEBPACK_IMPORTED_MODULE_8__.UsageError(`Failed to successfully resolve '${descriptor.range}' to a valid ${descriptor.name} release`);
    const installSpec = await context.engine.ensurePackageManager(resolved);
    const exitCode = await _corepackUtils__WEBPACK_IMPORTED_MODULE_6__.runVersion(installSpec, resolved, binaryName, args, context);
    return exitCode;
}
async function main(argv, context) {
    const corepackVersion = __webpack_require__(/*! ../package.json */ "./package.json").version;
    const [firstArg, ...restArgs] = argv;
    const request = getPackageManagerRequestFromCli(firstArg, context);
    let cli;
    if (!request) {
        // If the first argument doesn't match any supported packa