void 0 ? void 0 : state.coercion) === `undefined`)
                        return pushError(state, `Unbound coercion result`);
                    state.coercions.push([(_a = state.p) !== null && _a !== void 0 ? _a : `.`, state.coercion.bind(null, context.value)]);
                }
                (_b = state === null || state === void 0 ? void 0 : state.coercions) === null || _b === void 0 ? void 0 : _b.push(...subCoercions);
            }
            return followups.every(spec => {
                return spec(context.value, state);
            });
        }
        finally {
            for (const revert of reverts) {
                revert();
            }
        }
    },
});
const isOptional = (spec) => makeValidator({
    test: (value, state) => {
        if (typeof value === `undefined`)
            return true;
        return spec(value, state);
    },
});
const isNullable = (spec) => makeValidator({
    test: (value, state) => {
        if (value === null)
            return true;
        return spec(value, state);
    },
});
const hasMinLength = (length) => makeValidator({
    test: (value, state) => {
        if (!(value.length >= length))
            return pushError(state, `Expected to have a length of at least ${length} elements (got ${value.length})`);
        return true;
    },
});
const hasMaxLength = (length) => makeValidator({
    test: (value, state) => {
        if (!(value.length <= length))
            return pushError(state, `Expected to have a length of at most ${length} elements (got ${value.length})`);
        return true;
    },
});
const hasExactLength = (length) => makeValidator({
    test: (value, state) => {
        if (!(value.length === length))
            return pushError(state, `Expected to have a length of exactly ${length} elements (got ${value.length})`);
        return true;
    },
});
const hasUniqueItems = ({ map, } = {}) => makeValidator({
    test: (value, state) => {
        const set = new Set();
        const dup = new Set();
        for (let t = 0, T = value.length; t < T; ++t) {
            const sub = value[t];
            const key = typeof map !== `undefined`
                ? map(sub)
                : sub;
            if (set.has(key)) {
                if (dup.has(key))
                    continue;
                pushError(state, `Expected to contain unique elements; got a duplicate with ${getPrintable(value)}`);
                dup.add(key);
            }
            else {
                set.add(key);
            }
        }
        return dup.size === 0;
    },
});
const isNegative = () => makeValidator({
    test: (value, state) => {
        if (!(value <= 0))
            return pushError(state, `Expected to be negative (got ${value})`);
        return true;
    },
});
const isPositive = () => makeValidator({
    test: (value, state) => {
        if (!(value >= 0))
            return pushError(state, `Expected to be positive (got ${value})`);
        return true;
    },
});
const isAtLeast = (n) => makeValidator({
    test: (value, state) => {
        if (!(value >= n))
            return pushError(state, `Expected to be at least ${n} (got ${value})`);
        return true;
    },
});
const isAtMost = (n) => makeValidator({
    test: (value, state) => {
        if (!(value <= n))
            return pushError(state, `Expected to be at most ${n} (got ${value})`);
        return true;
    },
});
const isInInclusiveRange = (a, b) => makeValidator({
    test: (value, state) => {
        if (!(value >= a && value <= b))
            return pushError(state, `Expected to be in the [${a}; ${b}] range (got ${value})`);
        return true;
    },
});
const isInExclusiveRange = (a, b) => makeValidator({
    test: (value, state) => {
        if (!(value >= a && value < b))
            return pushError(state, `Expected to be in the [${a}; ${b}[ range (got ${value})`);
        return true;
    },
});
const isInteger = ({ unsafe = false, } = {}) => makeValidator({
    test: (value, state) => {
        if (value !== Math.round(value))
            return pushError(state, `Expected to be an integer (got ${value})`);
        if (!Number.isSafeInteger(value))
            return pushError(state, `Expected to be a safe integer (got ${value})`);
        return true;
    },
});
const matchesRegExp = (regExp) => makeValidator({
    test: (value, state) => {
        if (!regExp.test(value))
            return pushError(state, `Expected to match the pattern ${regExp.toString()} (got ${getPrintable(value)})`);
        return true;
    },
});
const isLowerCase = () => makeValidator({
    test: (value, state) => {
        if (value !== value.toLowerCase())
            return pushError(state, `Expected to be all-lowercase (got ${value})`);
        return true;
    },
});
const isUpperCase = () => makeValidator({
    test: (value, state) => {
        if (value !== value.toUpperCase())
            return pushError(state, `Expected to be all-uppercase (got ${value})`);
        return true;
    },
});
const isUUID4 = () => makeValidator({
    test: (value, state) => {
        if (!uuid4RegExp.test(value))
            return pushError(state, `Expected to be a valid UUID v4 (got ${getPrintable(value)})`);
        return true;
    },
});
const isISO8601 = () => makeValidator({
    test: (value, state) => {
        if (!iso8601RegExp.test(value))
            return pushError(state, `Expected to be a valid ISO 8601 date string (got ${getPrintable(value)})`);
        return false;
    },
});
const isHexColor = ({ alpha = false, }) => makeValidator({
    test: (value, state) => {
        const res = alpha
            ? colorStringRegExp.test(value)
            : colorStringAlphaRegExp.test(value);
        if (!res)
            return pushError(state, `Expected to be a valid hexadecimal color string (got ${getPrintable(value)})`);
        return true;
    },
});
const isBase64 = () => makeValidator({
    test: (value, state) => {
        if (!base64RegExp.test(value))
            return pushError(state, `Expected to be a valid base 64 string (got ${getPrintable(value)})`);
        return true;
    },
});
const isJSON = (spec = isUnknown()) => makeValidator({
    test: (value, state) => {
        let data;
        try {
            data = JSON.parse(value);
        }
        catch (_a) {
            return pushError(state, `Expected to be a valid JSON string (got ${getPrintable(value)})`);
        }
        return spec(data, state);
    },
});
const hasRequiredKeys = (requiredKeys) => {
    const requiredSet = new Set(requiredKeys);
    return makeValidator({
        test: (value, state) => {
            const keys = new Set(Object.keys(value));
            const problems = [];
            for (const key of requiredSet)
                if (!keys.has(key))
                    problems.push(key);
            if (problems.length > 0)
                return pushError(state, `Missing required ${plural(problems.length, `property`, `properties`)} ${problems.map(name => `"${name}"`).join(`, `)}`);
            return true;
        },
    });
};
const hasForbiddenKeys = (forbiddenKeys) => {
    const forbiddenSet = new Set(forbiddenKeys);
    return makeValidator({
        test: (value, state) => {
            const keys = new Set(Object.keys(value));
            const problems = [];
            for (const key of forbiddenSet)
                if (keys.has(key))
                    problems.push(key);
            if (problems.length > 0)
                return pushError(state, `Forbidden ${plural(problems.length, `property`, `properties`)} ${problems.map(name => `"${name}"`).join(`, `)}`);
            return true;
        },
    });
};
const hasMutuallyExclusiveKeys = (exclusiveKeys) => {
    const exclusiveSet = new Set(exclusiveKeys);
    return makeValidator({
        test: (value, state)