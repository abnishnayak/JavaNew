 add custom logic to handle errors from the command or simply return
     * the parent class error handling.
     */
    async catch(error) {
        throw error;
    }
    async validateAndExecute() {
        const commandClass = this.constructor;
        const cascade = commandClass.schema;
        if (typeof cascade !== `undefined`) {
            const { isDict, isUnknown, applyCascade } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(__webpack_require__(/*! typanion */ "./.yarn/cache/typanion-npm-3.3.1-ee9997c7cf-212d2beb55.zip/node_modules/typanion/lib/index.js")); });
            const schema = applyCascade(isDict(isUnknown()), cascade);
            const errors = [];
            const coercions = [];
            const check = schema(this, { errors, coercions });
            if (!check)
                throw utils.formatError(`Invalid option schema`, errors);
            for (const [, op] of coercions) {
                op();
            }
      