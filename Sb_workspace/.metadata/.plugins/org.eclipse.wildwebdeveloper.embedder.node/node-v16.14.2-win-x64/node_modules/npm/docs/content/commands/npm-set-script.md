s__WEBPACK_IMPORTED_MODULE_7__.fetchAsJson(spec.url);
            const field = data[spec.fields.versions];
            return Array.isArray(field) ? field : Object.keys(field);
        }
        default: {
            throw new Error(`Unsupported specification ${JSON.stringify(spec)}`);
        }
    }
}
async function findInstalledVersion(installTarget, descriptor) {
    const installFolder = path__WEBPACK_IMPORTED_MODULE_2___default().join(installTarget, descriptor.name);
    let folderContent;
    try {
        folderContent = await fs__WEBPACK_IMPORTED_MODULE_1___default().promises.readdir(installFolder);
    }
    catch (error) {
        if (error.code === `ENOENT`) {
            folderContent = [];
        }
        else {
            throw error;
        }
    }
    const candidateVersions = [];
    for (const entry of folderContent) {
        // Some dot-folders tend to pop inside directories, especially on OSX
        if (entry.startsWith(`.`))
            continue;
        candidateVersions.push(entry);
    }
    const bestMatch = semver__WEBPACK_IMPORTED_MODULE_3___default().maxSatisfying(candidateVersions, descriptor.range);
    if (bestMatch === null)
        return null;
    return bestMatch;
}
async function installVersion(installTarget, locator, { spec }) {
    const { default: tar } = await Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! tar */ "./.yarn/cache/tar-npm-6.0.1-aedef672fb-498c4a5671.zip/node_modules/tar/index.js", 19));
    const installFolder = path__WEBPACK_IMPORTED_MODULE_2___default().join(installTarget, locator.name, locator.reference);
    if (fs__WEBPACK_IMPORTED_MODULE_1___default().existsSync(installFolder)) {
        _debugUtils__WEBPACK_IMPORTED_MODULE_4__.log(`Reusing ${locator.name}@${locator.reference}`);
        return installFolder;
    }
    const url = spec.url.replace(`{}`, locator.reference);
    _debugUtils__WEBPACK_IMPORTED_MODULE_4__.log(`Installing ${locator.name}@${locator.reference} from ${url}`);
    return await _fsUtils__WEBPACK_IMPORTED_MODULE_6__.mutex(installFolder, async () => {
        // Creating a temporary folder inside the install folder means that we
        // are sure it'll be in the same drive as the destination, so we can
        // just move it there atomically once we are done
        const tmpFolder = _folderUtils__WEBPACK_IMPORTED_MODULE_5__.getTemporaryFolder(installTarget);
        const stream = await _httpUtils__WEBPACK_IMPORTED_MODULE_7__.fetchUrlStream(url);
        const parsedUrl = new URL(url);
        const ext = path__WEBPACK_IMPORTED_MODULE_2___default().posix.extname(parsedUrl.pathname);
        let outputFile = null;
        let sendTo;
        if (ext === `.tgz`) {
            sendTo = tar.x({ strip: 1, cwd: tmpFolder });
        }
        else if (ext === `.js`) {
     