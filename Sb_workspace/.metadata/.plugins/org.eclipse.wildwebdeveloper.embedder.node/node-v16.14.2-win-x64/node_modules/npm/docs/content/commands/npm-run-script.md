
        }
        if (typeof lastKnownGood !== `object` || lastKnownGood === null)
            return definition.default;
        if (!Object.prototype.hasOwnProperty.call(lastKnownGood, packageManager))
            return definition.default;
        const override = lastKnownGood[packageManager];
        if (typeof override !== `string`)
            return definition.default;
        return override;
    }
    async activatePackageManager(locator) {
        const lastKnownGoodFile = this.getLastKnownGoodFile();
        let lastKnownGood;
        try {
            lastKnownGood = JSON.parse(await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.readFile(lastKnownGoodFile, `utf8`));
        }
        catch (_a) {
            // Ignore errors; too bad
        }
        if (typeof lastKnownGood !== `object` || lastKnownGood === null)
            lastKnownGood = {};
        lastKnownGood[locator.name] = locator.reference;
        await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.mkdir(path__WEBPACK_IMPORTED_MODULE_1___default().dirname(lastKnownGoodFile), { recursive: true });
        await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.writeFile(lastKnownGoodFile, `${JSON.stringify(lastKnownGood, null, 2)}\n`);
    }
    async ensurePackageManager(locator) {
        const definition = this.config.definitions[locator.name];
        if (typeof definition === `undefined`)
            throw new clipanion__WEBPACK_IMPORTED_MODULE_8__.UsageError(`This package manager (${locator.name}) isn't supported by this corepack build`);
        const ranges = Object.keys(definition.ranges).reverse();
        const range = ranges.find(range => _semverUtils__WEBPACK_IMPORTED_MODULE_6__.satisfiesWithPrereleases(locator.reference, range));
        if (typeof range === `undefined`)
            throw new Error(`Assertion failed: Specified resolution (${locator.reference}) isn't supported by any of ${ranges.join(`, `)}`);
        const installedLocation = await _corepackUtils__WEBPACK_IMPORTED_MODULE_5__.installVersion(_folderUtils__WEBPACK_IMPORTED_MODULE_4__.getInstallFolder(), locator, {
            spec: definition.ranges[range],
        });
        return {
            location: installedLocation,
            spec: definition.ranges[range],
        };
    }
    async resolveDescriptor(descriptor, { allowTags = false, useCache = true } = {}) {
        const definition = this.config.definitions[descriptor.name];
        if (typeof definition === `undefined`)
            throw new clipanion__WEBPACK_IMPORTED_MODULE_8__.UsageError(`This package manager (${descriptor.name}) isn't supported by this corepack build`);
        let finalDescriptor = descriptor;
        if (descriptor.range.match(/^[a-z-]+$/)) {
            if (!allowTags)
                throw new clipanion__WEBPACK_IMPORTED_MODULE_8__.UsageError(`Packages managers can't be referended via tags in this context`);
            // We only resolve tags from the latest registry entry
            const ranges = Object.keys(definition.ranges);
            const tagRange = ranges[ranges.length - 1];
            const tags = await _corepackUtils__WEBPACK_IMPORTED_MODULE_5__.fetchAvailableTags(definition.ranges[tagRange].registry);
            if (!Object.prototype.hasOwnProperty.call(tags, descriptor.range))
                throw new clipanion__WEBPACK_IMPORTED_MODULE_8__.UsageError(`Tag not found (${descriptor.range})`);
            finalDescriptor = {
                name: descriptor.name,
                range: tags[descriptor.range],
            };
        }
        // If a compatible version is already installed, no need to query one
        // from the remote listings
        const cachedVersion = await _corepackUtils__WEBPACK_IMPORTED_MODULE_5__.findInstalledVersion(_folderUtils__WEBPACK_IMPORTED_MODULE_4__.getInstallFolder(), finalDescriptor);
        if (cachedVersion !== null && useCache)
            return { name: finalDescriptor.name, reference: cachedVersion };
        const candidateRangeDefinitions = Object.keys(definition.ranges).filter(range => {
            return _semverUtils__WEBPACK_IMPORTED_MODULE_6__.satisfiesWithPrereleases(finalDescriptor.range, range);
        });
        const tagResolutions = await Promise.all(candidateRangeDefinitions.map(async (range) => {
            return [range, await _corepackUtils__WEBPACK_IMPORTED_MODULE_5__.fetchAvailableVersions(definition.ranges[range].registry)];
        }));
        // If a version is available under multiple strategies (for example if
        // Yarn is published to both the v1 package and git), we only care
        // about the latest one
        const resolutionMap = new Map();
        for (const [range, resolutions] of tagResolutions)
            for (const entry of resolutions)
                resolutionMap.set(entry, range);
        const candidates = [...resolutionMap.keys()];
        const maxSatisfying = semver__WEBPACK_IMPORTED_MODULE_2___default().maxSatisfying(candidates, finalDescriptor.range);
        if (maxSatisfying === null)
            return null;
        return { name: finalDescriptor.name, reference: maxSatisfying };
    }
    getLastKnownGoodFile() {
        return path__WEBPACK_IMPORTED_MODULE_1___default().join(_folderUtils__WEBPACK_IMPORTED_MODULE_4__.getInstallFolder(), `lastKnownGood.json`);
    }
}


/***/ }),

/***/ "./sources/commands/Disable.ts":
/*!*************************************!*\
  !*** ./sources/commands/Disable.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DisableCommand": () => (/* binding */ DisableCommand)
/* harmony export */ });
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! clipanion */ "./.yarn/__virtual__/clipanion-virtual-119dc92083/0/cache/clipanion-npm-3.0.1-901533eeed-3a4b0c1e7d.zip/node_modules/clipanion/lib/advanced/index.js");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var which__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! which */ "./.yarn/cache/which-npm-2.0.2-320ddf72f7-1a5c563d3c.zip/node_modules/which/which.js");
/* harmony import */ var which__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(which__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types */ "./sources/types.ts");





class DisableCommand extends clipanion__WEBPACK_IMPORTED_MODULE_4__.Command {
    constructor() {
        super(...arguments);
        this.installDirectory = clipanion__WEBPACK_IMPORTED_MODULE_4__.Option.String(`--install-directory`, {
            description: `Where the shims are located`,
        });
        this.names = clipanion__WEBPACK_IMPORTED_MODULE_4__.Option.Rest();
    }
    async execute() {
        let installDirectory = this.installDirectory;
        // Node always call realpath on the module it executes, so we already
        // lost track of how the binary got called. To find it back, we need to
        // iterate over the PATH variable.
        if (typeof installDirectory === `undefined`)
            installDirectory = path__WEBPACK_IMPORTED_MODULE_1___default().dirname(await which__WEBPACK_IMPORTED_MODULE_2___default()(`corepack`));
        cons