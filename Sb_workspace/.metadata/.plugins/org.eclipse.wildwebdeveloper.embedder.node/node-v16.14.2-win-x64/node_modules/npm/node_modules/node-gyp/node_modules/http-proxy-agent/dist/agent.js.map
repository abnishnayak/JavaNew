ng it during
        # generation time, but we return the un-joined version because the build
        # will occur in that directory. We only write the file if the contents
        # have changed so that simply regenerating the project files doesn't
        # cause a relink.
        build_dir_generated_name = os.path.join(build_dir, generated_name)
        gyp.common.EnsureDirExists(build_dir_generated_name)
        f = gyp.common.WriteOnDiff(build_dir_generated_name)
        f.write(generated_manifest_contents)
        f.close()
        manifest_files = [generated_name]

        if allow_isolation:
            flags.append("/ALLOWISOLATION")

        manifest_files += self._GetAdditionalManifestFiles(config, gyp_to_build_path)
        return flags, output_name, manifest_files

    def _GetAdditionalManifestFiles(self, config, gyp_to_build_path):
        """Gets additional manifest files that are added to the default one
        generated by the linker."""
        files = self._Setting(
            ("VCManifestTool", "AdditionalManifestFiles"), config, default=[]
        )
        if isinstance(files, str):
            files = files.split(";")
        return [
            os.path.normpath(gyp_to_build_path(self.ConvertVSMacros(f, config=config)))
            for f in files
        ]

    def IsUseLibraryDependencyInputs(self, config):
        """Returns whether the target should be linked via Use Library Dependency
        Inputs (using component .objs of a given .lib)."""
        config = self._TargetConfig(config)
        uldi = self._Setting(("VCLinkerTool", "UseLibraryDependencyInputs"), config)
        return uldi == "true"

    def IsEmbedManifest(self, config):
        """Returns whether manifest should be linked into binary."""
        config = self._TargetConfig(config)
        embed = self._Setting(
            ("VCManifestTool", "EmbedManifest"), config, default="true"
        )
        return embed == "true"

    def IsLinkIncremental(self, config):
        """Returns whether the target should be linked incrementally."""
        config = self._TargetConfig(config)
        link_inc = self._Setting(("VCLinkerTool", "LinkIncremental"), config)
        return link_inc != "1"

    def GetRcflags(self, config, gyp_to_ninja_path):
        """Returns the flags that need to be added to invocations of the resource
        compiler."""
        config = self._TargetConfig(config)
        rcflags = []
        rc = self._GetWrapper(
            self, self.msvs_settings[config], "VCResourceCompilerTool", append=rcflags
        )
        rc("AdditionalIncludeDirectories", map=gyp_to_ninja_path, prefix="/I")
        rcflags.append("/I" + gyp_to_ninja_path("."))
        rc("PreprocessorDefinitions", prefix="/d")
        # /l arg must be in hex without leading '0x'
        rc("Culture", prefix="/l", map=lambda x: hex(int(x))[2:])
        return rcflags

    def BuildCygwinBashCommandLine(self, args, path_to_base):
        """Build a command line that runs args via cygwin bash. We assume that all
        incoming paths are in Windows normpath'd form, so they need to be
        converted to posix style for the part of the command line that's passed to
        bash. We also have to do some Visual Studio macro emulation here because
        various rules use magic VS names for things. Also note that rules that
        contain ninja variables cannot be fixed here (for example ${source}), so
        the outer generator needs to make sure that the paths that are written out
        are in posix style, if the command line will be used here."""
        cygwin_dir = os.path.normpath(
            os.path.join(path_to_base, self.msvs_cygwin