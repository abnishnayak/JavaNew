lback: (atRule: Rule, index: number) => any): boolean | void;
        walkRules(callback: (atRule: Rule, index: number) => any): boolean | void;
        walkRules(selectorFilter: any, callback?: (atRule: Rule, index: number) => any): boolean | void;
        /**
         * Traverses the container's descendant nodes, calling `callback` for each
         * comment. Like container.each(), this method is safe to use if you are
         * mutating arrays during iteration.
         * @param callback Iterator called for each comment node within the container.
         */
        walkComments(callback: (comment: Comment, indexed: number) => any): void | boolean;
        /**
         * Passes all declaration values within the container that match pattern
         * through the callback, replacing those values with the returned result of
         * callback. This method is useful if you are using a custom unit or
         * function and need to iterate through all values.
         * @param pattern Pattern that we need to replace.
         * @param options Options to speed up the search.
         * @param callbackOrReplaceValue String to replace pattern or callback
         * that will return a new value. The callback will receive the same
         * arguments as those passed to a function parameter of String#replace.
         */
        replaceValues(pattern: string | RegExp, options: {
            /**
             * Property names. The method will only search for values that match
             * regexp  within declarations of listed properties.
             */
            props?: string[];
            /**
             * Used to narrow down values and speed up the regexp search. Searching
             * every single value with a regexp can be slow. If you pass a fast
             * string, PostCSS will first check whether the value contains the fast
             * string; and only if it does will PostCSS check that value against
             * regexp. For example, instead of just checking for /\d+rem/ on all
             * values, set fast: 'rem' to first check whether a value has the rem
             * unit, and only if it does perform the regexp check.
             */
            fast?: string;
        }, callbackOrReplaceValue: string | {
            (substring: string, ...args: any[]): string;
        }): this;
        replaceValues(pattern: string | RegExp, callbackOrReplaceValue: string | {
            (substring: string, ...args: any[]): string;
        }): this;
        /**
         * Inserts new nodes to the beginning of the container.
         * Because each node class is identifiable by unique properties, use the
         * following shortcuts to create nodes in insert methods:
         *     root.prepend({ name: '@charset', params: '"UTF-8"' }); // at-rule
         *     root.prepend({ selector: 'a' });                       // rule
         *     rule.prepend({ prop: 'color', value: 'black' });       // declaration
         *     rule.prepend({ text: 'Comment' })                      // comment
         * A string containing the CSS of the new element can also be used. This
         * approach is slower than the above shortcuts.
         *     root.prepend('a {}');
         *     root.first.prepend('color: black; z-index: 1');
         * @param nodes New nodes.
         * @returns This container for chaining.
         */
        prepend(...nodes: (Node | object | string)[]): this;
        /**
         * Inserts new nodes to the end of the container.
         * Because each node class is identifiable by unique properties, use the
         * following shortcuts to create nodes in insert methods:
         *     root.append({ name: '@charset', params: '"UTF-8"' }); // at-rule
         *     root.append({ selector: 'a' });                       // rule
         *     rule.append({ prop: 'color', value: 'black' });       // declaration
         *     rule.append({ text: 'Comment' })                      // comment
         * A string containing the CSS of the new element can also be used. This
         * approach is slower than the above shortcuts.
         *     root.append('a {}');
         *     root.first.append('color: black; z-index: 1');
         * @param nodes New nodes.
         * @returns This container for chaining.
         */
        append(...nodes: (Node | object | string)[]): this;
        /**
         * Insert newNode before oldNode within the container.
         * @param oldNode Child or child's index.
         * @returns This container for chaining.
         */
        insertBefore(oldNode: ChildNode | number, newNode: ChildNode | object | string): this;
        /**
         * Insert newNode after oldNode within the container.
         * @param oldNode Child or child's index.
         * @returns This container for chaining.
         */
        insertAfter(oldNode: ChildNode | number, newNode: ChildNode | object | string): this;
        /**
         * Removes the container from its parent and cleans the parent property in the
         * container and its children.
         * @returns This container for chaining.
         */
        remove(): this;
        /**
         * Removes child from the container and cleans the parent properties
         * from the node and its children.
         * @param child Child or child's index.
         * @returns This container for chaining.
         */
        removeChild(child: ChildNode | number): this;
        /**
         * Removes all children from the container and cleans their parent
         * properties.
         * @returns This container for chaining.
         */
        removeAll(): this;
    }
    interface ContainerNewProps extends NodeNewProps {
        /**
         * Contains the container's children.
         */
        nodes?: ChildNode[];
        raws?: ContainerRaws;
    }
    interface ContainerRaws extends NodeRaws {
        indent?: string;
    }
    interface JsonContainer extends JsonNode {
        /**
         * Contains the container's children.
         */
        nodes?: ChildNode[];
        /**
         * @returns The container's first child.
         */
        first?: ChildNode;
        /**
         * @returns The container's last child.
         */
        last?: ChildNode;
    }
    /**
     * Represents a CSS file and contains all its parsed nodes.
     */
    interface Root extends ContainerBase {
        type: 'root';
        /**
         * Inherited from Container. Should always be undefined for a Root node.
         */
        parent: void;
        /**
         * @param overrides New properties to override in the clone.
         * @returns A clone of this node. The node and its (cloned) children will
         * have a clean parent and code style properties.
         */
        clone(overrides?: object): this;
        /**
         * @returns A Result instance representing the root's CSS.
         */
        toResult(options?: {
            /**
             * The path where you'll put the output CSS file. You should always
             * set "to" to generate correct source maps.
             */
            to?: string;
            map?: SourceMapOptions;
        }): Result;
        /**
         * Removes child from the root node, and the parent properties of node and
         * its children.
         * @param child Child or child's index.
         * @returns This root node for chaining.
         */
        removeChild(child: ChildNode | number): this;
    }
    interface RootNewProps extends ContainerNewProps {
    }
    interface JsonRoot extends JsonContainer {
    }
    /**
     * Represents an at-rule. If it's followed in the CSS by a {} block, this
     * node will have a nodes property representing its children.
     */
    interface AtRule extends ContainerBase {
        type: 'atrule';
        /**
         * Returns the atrule's parent node.
         */
        parent: Container;
        /**
         * The identifier that immediately follows the @.
         */
        name: string;
        /**
         * These are the values that follow the at-rule's name, but precede any {}
         * block. The spec refers to this area as the at-rule's "prelude".
         */
        params: string;
        /**
         * @param overrides New properties to override in the clone.
         * @returns A clone of this node. The node and its (cloned) children will
         * have a clean parent and code style properties.
         */
        clone(overrides?: object): this;
    }
    interface AtRuleNewProps extends ContainerNewProps {
        /**
         * The identifier that immediately follows the @.
         */
        name?: string;
        /**
         * These are the values that follow the at-rule's name, but precede any {}
         * block. The spec refers to this area as the at-rule's "prelude".
         */
        params?: string | number;
        raws?: AtRuleRaws;
    }
    interface AtRuleRaws extends NodeRaws {
 