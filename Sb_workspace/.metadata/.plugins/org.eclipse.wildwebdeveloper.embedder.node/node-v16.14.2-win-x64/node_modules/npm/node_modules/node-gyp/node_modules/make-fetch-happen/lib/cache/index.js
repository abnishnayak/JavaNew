t of stdout, and write filtered versions. Output we want
        # to filter is pairs of lines that look like this:
        # Processing C:\Program Files (x86)\Microsoft SDKs\...\include\objidl.idl
        # objidl.idl
        lines = out.splitlines()
        prefixes = ("Processing ", "64 bit Processing ")
        processing = {os.path.basename(x) for x in lines if x.startswith(prefixes)}
        for line in lines:
            if not line.startswith(prefixes) and line not in processing:
                print(line)
        return popen.returncode

    def ExecAsmWrapper(self, arch, *args):
        """Filter logo banner from invocations of asm.exe."""
        env = self._GetEnv(arch)
        popen = subprocess.Popen(
            args, shell=True, env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )
        out = popen.communicate()[0].decode("utf-8")
        for line in out.splitlines():
            if (
                not line.startswith("Copyright (C) Microsoft Corporation")
                and not line.startswith("Microsoft (R) Macro Assembler")
                and not line.startswith(" Assembling: ")
                and line
            ):
                print(line)
        return popen.returncode

    def ExecRcWrapper(self, arch, *args):
        """Filter logo banner from invocations of rc.exe. Older versions of RC
    don't support the /nologo flag."""
        env = self._GetEnv(arch)
        popen = subprocess.Popen(
            args, shell=True, env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )
        out = popen.communicate()[0].decode("utf-8")
        for line in out.splitlines():
            if (
                not line.startswith("Microsoft (R) Windows (R) Resource Compiler")
           