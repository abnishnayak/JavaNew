rent) {
              this.fsParent.fsChildren.delete(this)
            }
            parent.fsChildren.add(this)
            this[_fsParent] = parent
          }
          break
        }
      }

      // if it doesn't have a parent, it's a top node
      if (!this.parent) {
        root.tops.add(this)
      } else {
        root.tops.delete(this)
      }

      // assign parentage for any nodes that need to have this as a parent
      // this can happen when we have a node at nm/a/nm/b added *before*
      // the node at nm/a, which might have the root node as a fsParent.
      // we can't rely on the public setter here, because it calls into
      // this function to set up these references!
      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`
      const isChild = n => n.location === nmloc + n.name
      // check dirname so that /foo isn't treated as the fsparent of /foo-bar
      const isFsChild = n => {
        return dirname(n.path).startsWith(this.path) &&
          n !== this &&
          !n.parent &&
          (!n.fsParent ||
            n.fsParent === this ||
            dirname(this.path).startsWith(n.fsParent.path))
      }
      const isKid = n => isChild(n) || isFsChild(n)

      // on