#!/usr/bin/env python3

# Copyright (c) 2012 Google Inc. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Make the format of a vcproj really pretty.

   This script normalize and sort an xml. It also fetches all the properties
   inside linked vsprops and include them explicitly in the vcproj.

   It outputs the resulting xml to stdout.
"""


import os
import sys

from xml.dom.minidom import parse
from xml.dom.minidom import Node

__author__ = "nsylvain (Nicolas Sylvain)"
ARGUMENTS = None
REPLACEMENTS = dict()


def cmp(x, y):
    return (x > y) - (x < y)


class CmpTuple:
    """Compare function between 2 tuple."""

    def __call__(self, x, y):
        return cmp(x[0], y[0])


class CmpNode:
    """Compare function between 2 xml nodes."""

    def __call__(self, x, y):
        def get_string(node):
            node_string = "node"
            node_string += node.nodeName
            if node.nodeValue:
                node_string += node.nodeValue

            if node.attributes:
                # We first sort by name, if present.
                node_string += node.getAttribute("Name")

                all_nodes = []
                for (name, value) in node.attributes.items():
                    all_nodes.append((name, value))

                all_nodes.sort(CmpTuple())
                for (name, value) in all_nodes:
                    node_string += name
                    node_string += value

            return node_string

        return cmp(get_string(x), get_string(y))


def PrettyPrintNode(node, indent=0):
    if node.nodeType == Node.TEXT_NODE:
        if node.data.strip():
            print("{}{}".format(" " * indent, node.data.strip()))
        return

    if node.childNodes:
        node.normalize()
    # Get the number of attributes
    attr_count = 0
    if node.attributes:
        attr_count = node.attributes.length

    # Print the main tag
    if attr_count == 0:
        print("{}<{}>".format(" " * indent, node.nodeName))
    else:
        print("{}<{}".format(" " * indent, node.nodeName))

        all_attributes = []
        for (name, value) in node.attributes.items():
            all_attributes.append((name, value))
            all_attributes.sort(CmpTuple())
        for (name, value) in all_attributes:
            print('{}  {}="{}"'.format(" " * indent, name, value))
        print("%s>" % (" " * indent))
    if node.nodeValue:
        print("{}  {}".format(" " * indent, node.nodeValue))

    for sub_node in node.childNodes:
        PrettyPrintNode(sub_node, indent=indent + 2)
    print("{}</{}>".format(" " * indent, node.nodeName))


def FlattenFilter(node):
    """Returns a list of all the node and sub nodes."""
    node_list = []

    if node.attributes and node.getAttribute("Name") == "_excluded_files":
        # We don't add the "_excluded_files" filter.
        return []

    for current in node.childNodes:
        if current.nodeName == "Filter":
            node_list.extend(FlattenFilter(current))
        else:
            node_list.append(current)

    return node_list


def FixFilenames(filenames, current_directory):
    new_list = []
    for filename in filenames:
        if filename:
            for key in REPLACEMENTS:
                filename = filename.replace(key, REPLACEMENTS[key])
            os.chdir(current_directory)
            filename = filename.strip("\"' ")
            if filename.startswith("$"):
                new_list.append(filename)
            else:
                new_list.append(os.path.abspath(filename))
    return new_list


def AbsoluteNode(node):
    """Makes all the properties we know about in this node absolute."""
    if node.attributes:
        for (name, value) in node.attributes.items():
            if name in [
                "InheritedPropertySheets",
                "RelativePath",
                "AdditionalIncludeDirectories",
                "IntermediateDirectory",
                "OutputDirectory",
                "AdditionalLibraryDirectories",
            ]:
                # We want to fix up these paths
                path_list = value.split(";")
                new_list = FixFilenames(path_list, os.path.dirname(ARGUMENTS[1]))
                node.setAttribute(name, ";".join(new_list))
            if not value:
                node.removeAttribute(name)


def CleanupVcproj(node):
    """For each sub node, we call recursively this function."""
    for sub_node in node.childNodes:
        AbsoluteNode(sub_node)
        CleanupVcproj(sub_node)

    # Normalize the node, and remove all extraneous whitespaces.
    for sub_node in node.childNodes:
        if sub_node.nodeType == Node.TEXT_NODE:
            sub_node.data = sub_node.data.replace("\r", "")
            sub_node.data = sub_node.data.replace("\n", "")
            sub_node.data = sub_node.data.rstrip()

    # Fix all the semicolon separated attributes to be sorted, and we also
    # remove the dups.
    if node.attributes:
        for (name, value) in node.attributes.items():
            sorted_list = sorted(value.split(";"))
            unique_list = []
            for i in sorted_list:
                if not unique_list.count(i):
                    unique_list.append(i)
            node.setAttribute(name, ";".join(unique_list))
            if not value:
                node.removeAttribute(name)

    if node.childNodes:
        node.normalize()

    # For each node, take a copy, and remove it from the list.
    node_array = []
    while node.childNodes and node.childNodes[0]:
        # Take a copy of the node and remove it from the list.
        current = node.childNodes[0]
        node.removeChild(current)

        # If the child is a filter, we want to append all its children
        # to this same list.
        if current.nodeName == "Filter":
            node_array.extend(FlattenFilter(current))
        else:
            node_array.append(current)

    # Sort the list.
    node_array.sort(CmpNode())

    # Insert the nodes in the correct order.
    for new_node