r, setting = line.split("=", 1)
                if envvar == "path":
                    # Our own rules (for running gyp-win-tool) and other actions in
                    # Chromium rely on python being in the path. Add the path to this
                    # python here so that if it's not in the path when ninja is run
                    # later, python will still be found.
                    setting = os.path.dirname(sys.executable) + os.pathsep + setting
                env[var.upper()] = setting
                break
    for required in ("SYSTEMROOT", "TEMP", "TMP"):
        if required not in env:
            raise Exception(
                'Environment variable "%s" '
                "required to be set to valid path" % required
            )
    return env


def _FormatAsEnvironmentBlock(envvar_dict):
    """Format as an 'environment block' directly suitable for CreateProcess.
    Briefly this is a list of key=value\0, terminated by an additional \0. See
    CreateProcess documentation for more details."""
    block = ""
    nul = "\0"
    for key, value in envvar_dict.items():
        block += key + "=" + value + nul
    block += nul
    return block


def _ExtractCLPath(output_of_where):
    """Gets the path to cl.exe based on the output of calling the environment
    setup batch file, followed by the equivalent of `where`."""
    # Take the first line, as that's the first found in the PATH.
    for line in output_of_where.strip().splitlines():
        if line.startswith("LOC:"):
            return line[len("LOC:") :].strip()


def GenerateEnvironmentFiles(
    toplevel_build_dir, generator_flags, system_includes, open_out
):
    """It's not sufficient to have the absolute path to the compiler, linker,
    etc. on Windows, as those tools rely on .dlls being in the PATH. We also
    need to support both x86 and x64 compilers within the same build (to support
    msvs_target_platform hackery). Different architectures require a different
    compiler binary, and different supporting environment variables (INCLUDE,
    LIB, LIBPATH). So, we extract the environment here, wrap all invocations
    of compiler tools (cl, link, lib, rc, midl, etc.) via win_tool.py which
    sets up the environment, and then we do not prefix the compiler with
    an absolute path, instead preferring something like "cl.exe" in the rule
    which will then run whichever the environment setup has put in the path.
    When the following procedure to generate environment files does not
    meet your requirement (e.g. for custom toolchains), you can pass
    "-G ninja_use_custom_environment_files" to the gyp to suppress file
    generation and use custom environment files prepared by yourself."""
    archs = ("x86", "x64")
    if generator_flags.get("ninja_use_custom_environment_files", 0):
        cl_paths = {}
        for arch in archs:
            cl_paths[arch] = "cl.exe"
        return cl_paths
    vs = GetVSVersion(generator_flags)
    cl_paths = {}
    for arch in archs:
        # Extract environment variables for subprocesses.
        args = vs.SetupScript(arch)
        args.extend(("&&", "set"))
        popen = subprocess.Popen(
            args, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )
        variables = popen.communicate()[0].decode("utf-8")
        if popen.returncode != 0:
            raise Exception('"%s" failed with error %d' % (args, popen.returncode))
        env = _ExtractImportantEnvironment(variables)

        # Inject system includes from gyp files into INCLUDE.
        if system_includes:
            system_includes = system_includes | OrderedSet(
                env.get("INCLUDE", "").split(";")
            )
            env["INCLUDE"] = ";".join(system_includes)

        env_block = _FormatAsEnvironmentBlock(env)
        f = open_out(os.path.join(toplevel_build_dir, "environment." + arch), "w")
        f.write(env_block)
        f.close()

        # Find cl.exe location for this architecture.
        args = vs.SetupScript(arch)
        args.extend(
            ("&&", "for", "%i", "in", "(cl.exe)", "do", "@echo", "LOC:%~$PATH:i")
        )
        popen = subprocess.Popen(args, shell=True, stdout=subprocess.PIPE)
        output = popen.communicate()[0].decode("utf-8")
        cl_paths[arch] = _ExtractCLPath(output)
    return cl_paths


def VerifyMissingSources(sources, build_dir, generator_flags, gyp_to_ninja):
    """Emulate behavior of msvs_error_on_missing_sources present in the msvs
    generator: Check that all regular source files, i.e. not created at run time,
    exist on disk. Missing files cause needless recompilation when building via
    VS, and we want this check to match for people/bots that build using ninja,
    so they're not surprised when the VS build fails."""
    if int(generator_flags.get("msvs_error_on_missing_sources", 0)):
        no_specials = filter(lambda x: "$" not in x, sources)
        relative = [os.path.join(build_dir, gyp_to_ninja(s)) for s in no_specials]
        missing = [x for x in relative if not os.path.exists(x)]
        if missing:
            # They'll look like out\Release\..\..\stuff\things.cc, so normalize the
            # path for a slightly less crazy looking output.
            cleaned_up = [os.path.normpath(x) for x in missing]
            raise Exception("Missing input files:\n%s" % "\n".join(cleaned_up))


# Sets some values in default_variables, which