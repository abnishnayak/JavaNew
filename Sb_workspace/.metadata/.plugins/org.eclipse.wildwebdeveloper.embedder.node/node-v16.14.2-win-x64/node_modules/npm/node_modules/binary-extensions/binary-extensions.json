// Given a dep, a node that depends on it, and the edge representing that
// dependency, place the dep somewhere in the node's tree, and all of its
// peer dependencies.
//
// Handles all of the tree updating needed to place the dep, including
// removing replaced nodes, pruning now-extraneous or invalidated nodes,
// and saves a set of what was placed and what needs re-evaluation as
// a result.

const localeCompare = require('@isaacs/string-locale-compare')('en')
const log = require('proc-log')
const deepestNestingTarget = require('./deepest-nesting-target.js')
const CanPlaceDep = require('./can-place-dep.js')
const {
  KEEP,
  CONFLICT,
} = CanPlaceDep
const debug = require('./debug.js')

const Link = require('./link.js')
const gatherDepSet = require('./gather-dep-set.js')
const peerEntrySets = require('./peer-entry-sets.js')

class PlaceDep {
  constructor (options) {
    const {
      dep,
      edge,
      parent = null,
    } = options
    this.name = edge.name
    this.dep = dep
    this.edge = edge
    this.canPlace = null

    this.target = null
    this.placed = null

    // inherit all these fields from the parent to ensure consistency.
    const {
      preferDedupe,
      force,
      explicitRequest,
      updateNames,
      auditReport,
      legacyBundling,
      strictPeerDeps,
      legacyPeerDeps,
      globalStyle,
    } = parent || options
    Object.assign(this, {
      preferDedupe,
      force,
      explicitRequest,
      updateNames,
      auditReport,
      legacyBundling,
      strictPeerDeps,
      legacyPeerDeps,
      globalStyle,
    })

    this.children = []
    this.parent = parent
    this.peerConflict = null

    this.needEvaluation = new Set()

    this.checks = new Map()

    this.place()
  }

  place () {
    const {
      edge,
      dep,
      preferDedupe,
      globalStyle,
      legacyBundling,
      explicitRequest,
      updateNames,
      checks,
    } = this

    // nothing to do if the edge is fine as it is
    if (edge.to &&
        !edge.error &&
        !explicitRequest &&
        !updateNames.includes(edge.name) &&
        !this.isVulnerable(edge.to)) {
      return
    }

    // walk up the tree until we hit either a top/root node, or a place
    // where the dep is not a peer dep.
    const start = this.getStartNode()

    