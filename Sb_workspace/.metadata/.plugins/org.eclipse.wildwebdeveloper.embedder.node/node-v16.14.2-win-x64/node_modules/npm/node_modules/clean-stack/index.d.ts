// Parse a field, coercing it to the best type available.
const typeDefs = require('./type-defs.js')
const envReplace = require('./env-replace.js')
const { resolve } = require('path')

const { parse: umaskParse } = require('./umask.js')

const parseField = (f, key, opts, listElement = false) => {
  if (typeof f !== 'string' && !Array.isArray(f)) {
    return f
  }

  const { platform, types, home, env } = opts

  // type can be array or a single thing.  coerce to array.
  const typeList = new Set([].concat(types[key]))
  const isPath = typeList.has(typeDefs.path.type)
  const isBool = typeList.has(typeDefs.Boolean.type)
  const isString = isPath || typeList.has(typeDefs.String.type)
  const isUmask = typeList.has(typeDefs.Umask.type)
  const isNumber = typeList.has(typeDefs.Number.type)
  const isList = !listElement && typeList.has(Array)

  if (Array.isArray(f)) {
    return !isList ? f : f.map(field => parseField(field, key, opts, true))
  }

  // now we know it's a string
  f = f.trim()

  // list types get put in the environment separated by double-\n
  // usually a single \n would suffice, but ca/cert configs can contain
  // line breaks and multiple entries.
  if (isList