"remoteGlobalIDString": other,
                    "remoteInfo": other.Name(),
                }
            )
            dependency = PBXTargetDependency(
                {"target": other, "targetProxy": container}
            )
            self.AppendProperty("dependencies", dependency)
        else:
            # Add a dependency to a target in a different project file.
            other_project_ref = pbxproject.AddOrGetProjectReference(other_pbxproject)[1]
            container = PBXContainerItemProxy(
                {
                    "containerPortal": other_project_ref,
                    "proxyType": 1,
                    "remoteGlobalIDString": other,
                    "remoteInfo": other.Name(),
                }
            )
            dependency = PBXTargetDependency(
                {"name": other.Name(), "targetProxy": container}
            )
            self.AppendProperty("dependencies", dependency)

    # Proxy all of these through to the build configuration list.

    def ConfigurationNamed(self, name):
        return self._properties["buildConfigurationList"].ConfigurationNamed(name)

    def DefaultConfiguration(self):
        return self._properties["buildConfigurationList"].DefaultConfiguration()

    def HasBuildSetting(self, key):
        return self._properties["buildConfigurationList"].HasBuildSetting(key)

    def GetBuildSetting(self, key):
        return self._properties["buildConfigurationList"].GetBuildSetting(key)

    def SetBuildSetting(self, key, value):
        return self._properties["buildConfigurationList"].SetBuildSetting(key, value)

    def AppendBuildSetting(self, key, value):
        return self._properties["buildConfigurationList"].AppendBuildSetting(key, value)

    def DelBuildSetting(self, key):
        return self._properties["buildConfigurationList"].DelBuildSetting(key)


# Redefine the type of the "target" property.  See PBXTargetDependency._schema
# above.
PBXTargetDependency._schema["target"][1] = XCTarget


class PBXNativeTarget(XCTarget):
    # buildPhases is overridden in the schema to be able to set defaults.
    #
    # NOTE: Contrary to most objects, it is advisable to set parent when
    # constructing PBXNativeTarget.  A parent of an XCTarget must be a PBXProject
    # object.  A parent reference is required for a PBXNativeTarget during
    # construction to be able to set up the target defaults for productReference,
    # because a PBXBuildFile object must be created for the target and it must
    # be added to the PBXProject's mainGroup hierarchy.
    _schema = XCTarget._schema.copy()
    _schema.update(
        {
            "buildPhases": [
                1,
                XCBuildPhase,
                1,
                1,
                [PBXSourcesBuildPhase(), PBXFrameworksBuildPhase()],
            ],
            "buildRules": [1, PBXBuildRule, 1, 1, []],
            "productReference": [0, PBXFileReference, 0, 1],
            "productType": [0, str, 0, 1],
        }
    )

    # Mapping from Xcode product-types to settings.  The settings are:
    #  filetype : used for explicitFileType in the project file
    #  prefix : the prefix for the file name
    #  suffix : the suffix for the file name
    _product_filetypes = {
        "com.apple.product-type.application": ["wrapper.application", "", ".app"],
        "com.apple.product-type.application.watchapp": [
            "wrapper.application",
            "",
            ".app",
        ],
        "com.apple.product-type.watchkit-extension": [
            "wrapper.app-extension",
            "",
            ".appex",
        ],
        "com.apple.product-type.app-extension": ["wrapper.app-extension", "", ".appex"],
        "com.apple.product-type.bundle": ["wrapper.cfbundle", "", ".bundle"],
        "com.apple.product-type.framework": ["wrapper.framework", "", ".framework"],
        "com.apple.product-type.library.dynamic": [
            "compiled.mach-o.dylib",
            "lib",
            ".dylib",
        ],
        "com.apple.product-type.library.static": ["archive.ar", "lib", ".a"],
        "com.apple.product-type.tool": ["compiled.mach-o.executable", "", ""],
        "com.apple.product-type.bundle.unit-test": ["wrapper.cfbundle", "", ".xctest"],
        "com.apple.product-type.bundle.ui-testing": ["wrapper.cfbundle", "", ".xctest"],
        "com.googlecode.gyp.xcode.bundle": ["compiled.mach-o.dylib", "", ".so"],
        "com.apple.product-type.kernel-extension": ["wrapper.kext", "", ".kext"],
    }

    def __init__(
        self,
        properties=None,
        id=None,
        parent=None,
        force_outdir=None,
        force_prefix=None,
        force_extension=None,
    ):
        # super
        XCTarget.__init__(self, properties, id, parent)

        if (
            "productName" in self._properties
            and "productType" in self._properties
            and "productReference" not in self._properties
            and self._properties["productType"] in self._product_filetypes
        ):
            products_group = None
            pbxproject = self.PBXProjectAncestor()
            if pbxproject is not None:
                products_group = pbxproject.ProductsGroup()

            if products_group is not None:
                (filetype, prefix, suffix) = self._product_filetypes[
                    self._properties["productType"]
                ]
                # Xcode does not have a distinct type for loadable modules that are
                # pure BSD targets (not in a bundle wrapper). GYP allows such modules
                # to be specified by setting a target type to loadable_module without
                # having mac_bundle set. These are mapped to the pseudo-product type
                # com.googlecode.gyp.xcode.bundle.
                #
                # By picking up this special type and converting it to a dynamic
                # library (com.apple.product-type.library.dynamic) with fix-ups,
                # single-file loadable modules can be produced.
                #
                # MACH_O_TYPE is changed to mh_bundle to produce the proper file type
                # (as opposed to mh_dylib). In order for linking to succeed,
                # DYLIB_CURRENT_VERSION and DYLIB_COMPATIBILITY_VERSION must be
                # cleared. They are meaningless for type mh_bundle.
                #
                # Finally, the .so extension is forcibly applied over the default
                # (.dylib), unless another forced extension is already selected.
                # .dylib is plainly wrong, and .bundle is used by loadable_modules in
                # bundle wrappers (com.apple.product-type.bundle). .so seems an odd
                # choice because it's used as the extension on many other systems that
                # don't distinguish between linkable shared libraries and non-linkable
                # loadable modules, but there's precedent: Python loadable modules on
                # Mac OS X use an .so extension.
                if self._properties["productType"] == "com.googlecode.gyp.xcode.bundle":
                    self._properties[
                        "productType"
                    ] = "com.apple.product-type.library.dynamic"
                    self.SetBuildSetting("MACH_O_TYPE", "mh_bundle")
                    self.SetBuildSetting("DYLIB_CURRENT_VERSION", "")
                    self.SetBuildSetting("DYLIB_COMPATIBILITY_VERSION", "")
                    if force_extension is None:
                        force_extension = suffix[1:]

                if (
                    self._properties["productType"]
         