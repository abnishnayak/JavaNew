ecomes collapsed into a/b, f1 will have a single parent
    a/b.  If someone later adds a/f2 to the project file, a/b can no longer be
    collapsed, and f1 winds up with parent b and grandparent a.  That would
    be sufficient to change f1's hash.

    To counteract this problem, hashables for all XCHierarchicalElements except
    for the main group (which has neither a name nor a path) are taken to be
    just the set of path components.  Because hashables are inherited from
    parents, this provides assurance that a/b/f1 has the same set of hashables
    whether its parent is b or a/b.

    The main group is a special case.  As it is permitted to have no name or
    path, it is permitted to use the standard XCObject hash mechanism.  This
    is not considered a problem because there can be only one main group.
    """

        if self == self.PBXProjectAncestor()._properties["mainGroup"]:
            # super
            return XCObject.Hashables(self)

        hashables = []

        # Put the name in first, ensuring that if TakeOverOnlyChild collapses
        # children into a top-level group like "Source", the name always goes
        # into the list of hashables without interfering with path components.
        if "name" in self._properties:
            # Make it less likely for people to manipulate hashes by following the
            # pattern of always pushing an object type value onto the list first.
            hashables.append(self.__class__.__name__ + ".name")
            hashables.append(self._properties["name"])

        # NOTE: This still has the problem that if an absolute path is encountered,
        # including paths with a sourceTree, they'll still inherit their parents'
        # hashables, even though the paths aren't relative to their parents.  This
        # is not expected to be much of a problem in practice.
        path = self.PathFromSourceTreeAndPath()
        if path is not None:
            components = path.split(posixpath.sep)
            for component in components:
                hashables.append(self.__class__.__name__ + ".path")
                hashables.append(component)

        hashables.extend(self._hashables)

        return hashables

    def Compare(self, other):
        # Allow comparison of these types.  PBXGroup has the highest sort rank;
        # PBXVariantGroup is treated as equal to PBXFileReference.
        valid_class_types = {
            PBXFileReference: "file",
            PBXGroup: "group",
            PBXVariantGroup: "file",
        }
        self_type = valid_class_types[self.__class__]
        other_type = valid_class_types[other.__class__]

        if self_type == other_type:
            # If the two objects are of the same sort rank, compare their names.
            return cmp(self.Name(), other.Name())

        # Otherwise, sort groups before everything else.
        if self_type == "group":
            return -1
        return 1

    def CompareRootGroup(self, other):
        # This function should be used only to compare direct children of the
        # containing PBXProject's mainGroup.  These groups should appear in the
        # listed order.
        # TODO(mark): "Build" is used by gyp.generator.xcode, perhaps the
        # generator should have a way of influencing this list rather than having
        # to hardcode for the generator here.
        order = [
            "Source",
            "Intermediates",
            "Projects",
            "Frameworks",
            "Products",
            "Build",
        ]

        # If the groups aren't in the listed order, do a name comparison.
        # Otherwise, groups in the listed order should come before those that
        # aren't.
        self_name = self.Name()
        other_name = other.Name()
        self_in = isinstance(self, PBXGroup) and self_name in order
        other_in = isinstance(self, PBXGroup) and other_name in order
        if not self_in and not other_in:
            return self.Compare(other)
        if self_name in order and other_name not in order:
            return -1
        if other_name in order and self_name not in order:
            return 1

        # If both groups are in the listed order, go by the defined order.
        self_index = order.index(self_name)
        other_index = order.index(other_name)
        if self_index < other_index:
            return -1
        if self_index > other_index:
            return 1
        return 0

    def PathFromSourceTreeAndPath(self):
        # Turn the object's sourceTree and path properties into a single flat
        # string of a form comparable to the path parameter.  If there's a
        # sourceTree property other than "<group>", wrap it in $(...) for the
        # comparison.
        components = []
        if self._properties["sourceTree"] != "<group>":
            components.append("$(" + self._properties["sourceTree"] + ")")
        if "path" in self._properties:
            components.append(self._properties["path"])

        if len(components) > 0:
            return posixpath.join(*components)

        return None

    def FullPath(self):
        # Returns a full path to self relative to the project file, or relative
        # to some other source tree.  Start with self, and walk up the chain of
        # parents prepending their paths, if any, until no more parents are
        # available (project-relative path) or until a path relative to some
        # source tree is found.
        xche = self
        path = None
        while isinstance(xche, XCHierarchicalElement) and (
            path is None or (not path.startswith("/") and not path.startswith("$"))
        ):
            this_path = xche.PathFromSourceTreeAndPath()
            if this_path is not None and path is not None:
                path = posixpath.join(this_path, path)
            elif this_path is not None:
                path = this_path
            xche = xche.parent

        return path


class PBXGroup(XCHierarchicalElement):
    """
  Attributes:
    _children_by_path: Maps pathnames of children of this PBXGroup to the
      actual child XCHierarchicalElement objects.
    _variant_children_by_name_and_path: Maps (name, path) tuples of
      PBXVariantGroup children to the actual child PBXVariantGroup objects.
  """

    _schema = XCHierarchicalElement._schema.copy()
    _schema.update(
        {
            "children": [1, XCHierarchicalElement, 1, 1, []],
            "name": [0, str, 0, 0],
            "path": [0, str, 0, 0],
        }
    )

    def __init__(self, properties=None, id=None, parent=None):
        # super
        XCHierarchicalElement.__init__(self, properties, id, parent)
        self._children_by_path = {}
        self._variant_children_by_name_and_path = {}
        for child in self._properties.get("children", []):
            self._AddChildToDicts(child)

    def Hashables(self):
        # super
        hashables = XCHierarchicalElement.Hashables(self)

        # It is not sufficient to just rely on name and parent to build a unique
        # hashable : a node could have two child PBXGroup sharing a common name.
        # To add entropy the hashable is enhanced with the names of all its
        # children.
        for child in self._properties.get("children", []):
            child_name = child.Name()
            if child_name is not None:
                hashables.append(child_name)

        return hashables

    def HashablesForChild(self):
        # To avoid a circular reference the hashables used to compute a child id do
        # not include the child names.
        return XCHierarchicalElement.Hashables(self)

    def _AddChildToDicts(self, child):
        # Sets up this PBXGroup object's dicts to reference the child properly.
        child_path = child.PathFromSourceTreeAndPath()
        if child_path:
            if child_path in self._children_by_path:
                raise ValueError("Found multiple children with path " + child_path)
            self._children_by_path[child_path] = child

        if isinstance(child, PBXVariantGroup):
            child_name = child._properties.get("name", None)
            key = (child_name, child_path)
            if key in self._variant_children_by_name_and_path:
                raise ValueError(
                    "Found multiple PBXVariantGroup children with "
                    + "name "
                    + str(child_name)
                    + " and path "
                    + str(child_path)
                )
            self._variant_children_by_name_and_path[key] = child

    def AppendChild(self, child):
        # Callers should use this instead of calling
        # AppendProperty('children', child) directly because this function
        # maintains the group's dicts.
        self.AppendProperty("children", child)
        self._AddChildToDicts(child)

    def GetChildByName(self, name):
        # This is not currently optimized with a dict as GetChildByPath is because
        # it has few callers.  Most callers probably want GetChildByPath.  This
        # function is only useful to get children that have names but no paths,
        # which is rare.  The children of the main group ("Source", "Products",
        # etc.) is pretty much the only case where this likely to come up.
        #
        # TODO(mark): Maybe this should raise an error if more than one child is
        # present with the same name.
        if "children" not in self._properties:
            return None

        for child in self._properties["children"]:
            if child.Name() == name:
                return child

        return None

    def GetChildByPath(self, path):
        if not path:
            return None

        if path in self._children_by_path:
            return self._children_by_path[path]

        return None

    def GetChildByRemoteObject(self, remote_object):
        # This method is a little bit esoteric.  Given a remote_object, which
        # should be a PBXFileReference in another project file, this method will
        # return this group's PBXReferenceProxy object serving as a local proxy
        # for the remote PBXFileReference.
        #
        # This function might benefit from a dict optimization as GetChildByPath
        # for some workloads, but profiling shows that it's not currently a
        # problem.
        if "children" not in self._properties:
            return None

        for child in self._properties["children"]:
            if not isinstance(child, PBXReferenceProxy):
                continue

            container_proxy = child._properties["remoteRef"]
            if container_proxy._properties["remoteGlobalI