""

        for configuration in self._properties["buildConfigurations"]:
            configuration.SetBaseConfiguration(value)


class PBXBuildFile(XCObject):
    _schema = XCObject._schema.copy()
    _schema.update(
        {
            "fileRef": [0, XCFileLikeElement, 0, 1],
            "settings": [0, str, 0, 0],  # hack, it's a dict
        }
    )

    # Weird output rules for PBXBuildFile.
    _should_print_single_line = True
    _encode_transforms = XCObject._alternate_encode_transforms

    def Name(self):
        # Example: "main.cc in Sources"
        return self._properties["fileRef"].Name() + " in " + self.parent.Name()

    def Hashables(self):
        # super
        hashables = XCObject.Hashables(self)

        # It is not sufficient to just rely on Name() to get the
        # XCFileLikeElement's name, because that is not a complete pathname.
        # PathHashables returns hashables unique enough that no two
        # PBXBuildFiles should wind up with the same set of hashables, unless
        # someone adds the same file multiple times to the same target.  That
        # would be considered invalid anyway.
        hashables.extend(self._properties["fileRef"].PathHashables())

        return hashables


class XCBuildPhase(XCObject):
    """Abstract base for build phase classes.  Not represented in a project
  file.

  Attributes:
    _files_by_path: A dict mapping each path of a child in the files list by
      path (keys) to the corresponding PBXBuildFile children (values).
    _files_by_xcfilelikeelement: A dict mapping each XCFileLikeElement (keys)
      to the corresponding PBXBuildFile children (values).
  """

    # TODO(mark): Some build phase types, like PBXShellScriptBuildPhase, don't
    # actually have a "files" list.  XCBuildPhase should not have "files" but
    # another abstract subclass of it should provide this, and concrete build
    # phase types that do have "files" lists should be derived from that new
    # abstract subclass.  XCBuildPhase should only provide buildActionMask and
    # runOnlyForDeploymentPostprocessing, and not files or the various
    # file-related methods and attributes.

    _schema = XCObject._schema.copy()
    _schema.update(
        {
            "buildActionMask": [0, int, 0, 1, 0x7FFFFFFF],
            "files": [1, PBXBuildFile, 1, 1, []],
            "runOnlyForDeploymentPostprocessing": [0, int, 0, 1, 0],
        }
    )

    def __init__(self, properties=None, id=None, parent=None):
        # super
        XCObject.__init__(self, properties, id, parent)

        self._files_by_path = {}
        self._files_by_xcfilelikeelement = {}
        for pbxbuildfile in self._properties.get("files", []):
            self._AddBuildFileToDicts(pbxbuildfile)

    def FileGroup(self, path):
        # Subclasses must override this by returning a two-element tuple.  The
        # first item in the tuple should be the PBXGroup to which "path" should be
        # added, either as a child or deeper descendant.  The second item should
        # be a boolean indicating whether files should be added into hierarchical
        # groups or one single flat group.
        raise NotImplementedError(self.__class__.__name__ + " must implement FileGroup")

    def _AddPathToDict(self, pbxbuildfile, path):
        """Adds path to the dict tracking paths belonging to this build phase.

    If the path is already a member of this build phase, raises an exception.
    """

        if path in self._files_by_path:
            raise ValueError("Found multiple build files with path " + path)
        self._files_by_path[path] = pbxbuildfile

    def _AddBuildFileToDicts(self, pbxbuildfile, path=None):
        """Maintains the _files_by_path and _files_by_xcfilelikeelement dicts.

    If path is specified, then it is the path that is being added to the
    phase, and pbxbuildfile must contain either a PBXFileReference directly
    referencing that path, or it must contain a PBXVariantGroup that itself
    contains a PBXFileReference referencing the path.

    If path is not specified, either the PBXFileReference's path or the paths
    of all children of the PBXVariantGroup are taken as being added to the
    phase.

    If the path is already present in the phase, raises an exception.

    If the PBXFileReference or PBXVariantGroup referenced by pbxbuildfile
    are already present in the phase, referenced by a different PBXBuildFile
    object, raises an exception.  This does not raise an exception when
    a PBXFileReference or PBXVariantGroup reappear and are referenced by the
    same PBXBuildFile that has already introduced them, because in the case
    of PBXVariantGroup objects, they may correspond to multiple paths that are
    not all added simultaneously.  When this situation occurs, the path needs
    to be added to _files_by_path, but nothing needs to change in
    _files_by_xcfilelikeelement, and the caller should have avoided adding
    the PBXBuildFile if it is already present in the list of children.
    """

        xcfilelikeelement = pbxbuildfile._properties["fileRef"]

        paths = []
        if path is not None:
            # It's best when the caller provides the path.
            if isinstance(xcfilelikeelement, PBXVariantGroup):
                paths.append(path)
        else:
            # If the caller didn't provide a path, there can be either multiple
            # paths (PBXVariantGroup) or one.
            if isinstance(xcfilelikeelement, PBXVariantGroup):
                for variant in xcfilelikeelement._properties["children"]:
                    paths.append(variant.FullPath())
            else:
                paths.append(xcfilelikeelement.FullPath())

        # Add the paths first, because if something's going to raise, the
        # messages provided by _AddPathToDict are more useful owing to its
        # having access to a real pathname and not just an object's Name().
        for a_path in paths:
            self._AddPathToDict(pbxbuildfile, a_path)

        # If another PBXBuildFile references this XCFileLikeElement, there's a
        # problem.
        if (
            xcfilelikeelement in self._files_by_xcfilelikeelement
            and self._files_by_xcfilelikeelement[xcfilelikeelement] != pbxbuildfile
        ):
            raise ValueError(
                "Found multiple build files for " + xcfilelikeelement.Name()
            )
        self._files_by_xcfilelikeelement[xcfilelikeelement] = pbxbuildfile

    def AppendBuildFile(self, pbxbuildfile, path=None):
        # Callers should use this instead of calling
        # AppendProperty('files', pbxbuildfile) directly because this function
        # maintains the object's dicts.  Better yet, callers can just call AddFile
        # with a pathname and not worry about building their own PBXBuildFile
        # objects.
        self.AppendProperty("files", pbxbuildfile)
        self._AddBuildFileToDicts(pbxbuildfile, path)

    def AddFile(self, path, settings=None):
        (file_group, hierarchical) = self.FileGroup(path)
        file_ref = file_group.AddOrGetFileByPath(path, hierarchical)

        if file_ref in self._files_by_xcfilelikeelement and isinstance(
            file_ref, PBXVariantGroup
        ):
            # There's already a PBXBuildFile in this phase corresponding to the
            # PBXVariantGroup.  path just provides a new variant that belongs to
            # the group.  Add the path to the dict.
            pbxbuildfile = self._files_by_xcfilelikeelement[file_ref]
            self._AddBuildFileToDicts(pbxbuildfile, path)
        else:
            # Add a new PBXBuildFile to get file_ref into the phase.
            if settings is None:
                pbxbuildfile = PBXBuildFile({"fileRef": file_ref})
            else:
                pbxbuildfile = PBXBuildFile({"fileRef": file_ref, "settings": settings})
            self.AppendBuildFile(pbxbuildfile, path)


class PBXHeadersBuildPhase(XCBuildPhase):
    # No additions to the schema relative to XCBuildPhase.

    def Name(self):
        return "Headers"

    def FileGroup(self, path):
        return self.PBXProjectAncestor().RootGroupForPath(path)


class PBXResourcesBuildPhase(XCBuildPhase):
    # No additions to the schema relative to XCBuildPhase.

    def Name(self):
        return "Resources"

    def FileGroup(self, path):
        return self.PBXProjectAncestor().RootGroupForPath(path)


class PBXSourcesBuildPhase(XCBuildPhase):
    # No additions to the schema relative to XCBuildPhase.

    def Name(self):
        return "Sources"

    def FileGroup(self, path):
        return self.PBXProjectAncestor().RootGroupForPath(path)


class PBXFrameworksBuildPhase(XCBuildPhase):
    # No additions to the schema relative to XCBuildPhase.

    def Name(self):
        return "Frameworks"

    def FileGroup(self, path):
        (root, ext) = posixpath.splitext(path)
        if ext != "":
            ext = ext[1:].lower()
        if ext == "o":
            # .o files are added to Xcode Frameworks phases, but conceptually aren't
            # frameworks, they're more like sources or intermediates. Redirect them
            # to show up in one of those other groups.
            return self.PBXProjectAncestor().RootGroupForPath(path)
        else:
            return (self.PBXProjectAncestor().FrameworksGroup(), False)


class PBXShellScriptBuildPhase(XCBuildPhase):
    _schema = XCBuildPhase._schema.copy()
    _schema.update(
        {
            "inputPaths": [1, str, 0, 1, []],
            "name": [0, str, 0, 0],
            "outputPaths": [1, str, 0, 1, []],
            "shellPath": [0, str, 0, 1, "/bin/sh"],
            "shellScript": [0, str, 0, 1],
            "showEnvVarsInLog": [0, int, 0, 0],
        }
    )

    def Name(self):
        if "name" in self._properties:
            return self._properties["name"]

        return "ShellScript"


class PBXCopyFilesBuildPhase(XCBuildPhase):
    _schema = XCBuildPhase._schema.copy()
    _schema.update(
        {
            "dstPath": [0, str, 0, 1],
            "dstSubfolderSpec": [0, int, 0, 1],
            "name": [0, str, 0, 0],
        }
    )

    # path_tree_re matches "$(DIR)/path", "$(DIR)/$(DIR2)/path" or just "$(DIR)".
    # Match group 1 is "DIR", group 3 is "path" or "$(DIR2") or "$(DIR2)/path"
    # or None. If group 3 is "path", group 4 will be None otherwise group 4 is
    # "DIR2" and group 6 is "path".
    path_tree_re = re.compile(r"^\$\((.*?)\)(/(\$\((.*?)\)(/(.*)|)|(.*)|)|)$")

    # path_tree_{first,second}_to_subfolder map names of Xcode variables to the
    # associated dstSubfolderSpec property value used in a PBXCopyFilesBuildPhase
    # object.
    path_tree_first_to_subfolder = {
        # Types that can be chosen via the Xcode UI.
        "BUILT_PRODUCTS_DIR": 16,  # Products Directory
        "BUILT_FRAMEWORKS_DIR": 10,  # Not an official Xcode macro.
        # Existed before support for the
        # names below was added. Maps to
        # "Frameworks".
    }

    path_tree_second_to_subfolder = {
        "WRAPPER_NAME": 1,  # Wrapper
        # Although Xcode's friendly name is "Executables", the destination
        # is demonstrably the value of the build setting
        # EXECUTABLE_FOLDER_PATH not EXECUTABLES_FOLDER_PATH.
        "EXECUTABLE_FOLDER_PATH": 6,  # Executables.
        "UNLOCALIZED_RESOURCES_FOLDER_PATH": 7,  # Resources
        "JAVA_FOLDER_PATH": 15,  # Java Resources
        "FRAMEWORKS_FOLDER_PATH": 10,  # Frameworks
        "SHARED_FRAMEWORKS_FOLDER_PATH": 11,  # Shared Frameworks
        "SHARED_SUPPORT_FOLDER_PATH": 12,  # Shared Support
        "PLUGINS_FOLDER_PATH": 13,  # PlugIns
        # For XPC Services, Xcode sets both dstPath and dstSubfolderSpec.
        # Note that it re-uses the BUILT_PRODUCTS_DIR value for
        # dstSubfolderSpec. dstPath is set below.
        "XPCSERVICES_FOLDER_PATH": 16,  # XPC Services.
    }

    def Name(self):
        if "name" in self._properties:
            return self._properties["name"]

        return "CopyFiles"

    def FileGroup(self, path):
        return self.PBXProjectAncestor().RootGroupForPath(path)

    def SetDestination(self, path):
        """Set the dstSubfolderSpec and dstPath properties from path.

    path may be specified in the same notation used for XCHierarch