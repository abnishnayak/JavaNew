

        product_group = None
        project_ref = None

        if other_pbxproject not in self._other_pbxprojects:
            # This project file isn't yet linked to the other one.  Establish the
            # link.
            product_group = PBXGroup({"name": "Products"})

            # ProductGroup is strong.
            product_group.parent = self

            # There's nothing unique about this PBXGroup, and if left alone, it will
            # wind up with the same set of hashables as all other PBXGroup objects
            # owned by the projectReferences list.  Add the hashables of the
            # remote PBXProject that it's related to.
            product_group._hashables.extend(other_pbxproject.Hashables())

            # The other project reports its path as relative to the same directory
            # that this project's path is relative to.  The other project's path
            # is not necessarily already relative to this project.  Figure out the
            # pathname that this project needs to use to refer to the other one.
            this_path = posixpath.dirname(self.Path())
            projectDirPath = self.GetProperty("projectDirPath")
            if projectDirPath:
                if posixpath.isabs(projectDirPath[0]):
                    this_path = projectDirPath
                else:
                    this_path = posixpath.join(this_path, projectDirPath)
            other_path = gyp.common.RelativePath(other_pbxproject.Path(), this_path)

            # ProjectRef is weak (it's owned by the mainGroup hierarchy).
            project_ref = PBXFileReference(
                {
                    "lastKnownFileType": "wrapper.pb-project",
                    "path": other_path,
                    "sourceTree": "SOURCE_ROOT",
                }
            )
            self.ProjectsGroup().AppendChild(project_ref)

            ref_dict = {"ProductGroup": product_group, "ProjectRef": project_ref}
            self._other_pbxprojects[other_pbxproject] = ref_dict
            self.AppendProperty("projectReferences", ref_dict)

            # Xcode seems to sort this list case-insensitively
            self._properties["projectReferences"] = sorted(
                self._properties["projectReferences"],
                key=lambda x: x["ProjectRef"].Name().lower
            )
        else:
            # The link already exists.  Pull out the relevnt data.
            project_ref_dict = self._other_pbxprojects[other_pbxproject]
            product_group = project_ref_dict["ProductGroup"]
            project_ref = project_ref_dict["ProjectRef"]

        self._SetUpProductReferences(other_pbxproject, product_group, project_ref)

        inherit_unique_symroot = self._AllSymrootsUnique(other_pbxproject, False)
        targets = other_pbxproject.GetProperty("targets")
        if all(self._AllSymrootsUnique(t, inherit_unique_symroot) for t in targets):
            dir_path = project_ref._properties["path"]
            product_group._hashables.extend(dir_path)

        return [product_group, project_ref]

    def _AllSymrootsUnique(self, target, inherit_unique_symroot):
        # Returns True if all configurations have a unique 'SYMROOT' attribute.
        # The value of inherit_unique_symroot decides, if a configuration is assumed
        # to inherit a unique 'SYMROOT' attribute from its parent, if it doesn't
        # define an explicit value for 'SYMROOT'.
        symroots = self._DefinedSymroots(target)
        for s in self._DefinedSymroots(target):
            if (
                s is not None
                and not self._IsUniqueSymrootForTarget(s)
                or s is None
                and not inherit_unique_symroot
            ):
                return False
        return True if symroots else inherit_unique_symroot

    def _DefinedSymroots(self, target):
        # Returns all values for the 'SYMROOT' attribute defined in all
        # configurations for this target. If any configuration doesn't define the
        # 'SYMROOT' attribute, None is added to the returned set. If all
        # configurations don't define the 'SYMROOT' attribute, an empty set is
        # returned.
        config_list = target.GetProperty("buildConfigurationList")
        symroots = set()
        for config in config_list.GetProperty("buildConfigurations"):
            setting = config.GetProperty("buildSettings")
            if "SYMROOT" in setting:
                symroots.add(setting["SYMROOT"])
            else:
                symroots.add(None)
        if len(symroots) == 1 and None in symroots:
            return set()
        return symroots

    def _IsUniqueSymrootForTarget(self, symroot):
        # This method returns True if all configurations in target contain a
        # 'SYMROOT' attribute that is unique for the given target. A value is
        # unique, if the Xcode macro '$SRCROOT' appears in it in any form.
        uniquifier = ["$SRCROOT", "$(SRCROOT)"]
        if any(x in symroot for x in uniquifier):
            return True
        return False

    def _SetUpProductReferences(self, other_pbxproject, product_group, project_ref):
        # TODO(mark): This only adds references to products in other_pbxproject
        # when they don't exist in this pbxproject.  Perhaps it should also
        # remove references from this pbxproject that are no longer present in
        # other_pbxproject.  Perhaps it should update various properties if they
        # change.
        for target in other_pbxproject._properties["targets"]:
            if not isinstance(target, PBXNativeTarget):
                continue

            other_fileref = target._properties["productReference"]
            if product_group.GetChildByRemoteObject(other_fileref) is None:
                # Xcode sets remoteInfo to the name of the target and not the name
                # of its product, despite this proxy being a reference to the product.
                container_item = PBXContainerItemProxy(
                    {
                        "containerPortal": project_ref,
                        "proxyType": 2,
                        "remoteGlobalIDString": other_fileref,
                        "remoteInfo": target.Name(),
                    }
                )
                # TODO(mark): Does sourceTree get copied straight over from the other
                # project?  Can the other project ever have lastKnownFileType here
                # instead of explicitFileType?  (Use it if so?)  Can path ever be
                # unset?  (I don't think so.)  Can other_fileref have name set, and
                # does it impact the PBXReferenceProxy if so?  These are the questions
                # that perhaps will be answered one day.
                reference_proxy = PBXReferenceProxy(
                    {
                        "fileType": other_fileref._properties["explicitFileType"],
                        "path": other_fileref._properties["path"],
                        "sourceTree": other_fileref._properties["sourceTree"],
                        "remoteRef": container_item,
                    }
                )

                product_group.AppendChild(reference_proxy)

    def SortRemoteProductReferences(self):
        # For each remote project file, sort the associated ProductGroup in the
        # same order that the targets are sorted in the remote project file.  This
        # is the sort order used by Xcode.

        def CompareProducts(x, y, remote_products):
            # x and y are PBXReferenceProxy objects.  Go through their associated
            # PBXContainerItem to get the remote PBXFileReference, which will be
            # present in the remote_products list.
            x_remote = x._properties["remoteRef"]._properties["remoteGlobalIDString"]
            y_remote = y._properties["remoteRef"]._properties["remoteGlobalIDString"]
            x_index = remote_products.index(x_remote)
            y_index = remote_products.index(y_remote)

            # Use the order of each remote PBXFileReference in remote_products to
            # determine the sort order.
            return cmp(x_index, y_index)

        for other_pbxproject, ref_dict in self._other_pbxprojects.items():
            # Build up a list of products in the remote project file, ordered the
            # same as the targets that produce them.
            remote_products = []
            for target in other_pbxproject._properties["targets"]:
                if not isinstance(target, PBXNativeTarget):
                    continue
                remote_products.append(target._properties["productReference"])

            # Sort the PBXReferenceProxy children according to the list of remote
            # products.
            product_group = ref_dict["ProductGroup"]
            product_group._properties["children"] = sorted(
                product_group._properties["children"],
                key=cmp_to_key(
                    lambda x, y, rp=remote_products: CompareProducts(x, y, rp)),
            )


class XCProjectFile(XCObject):
    _schema = XCObject._schema.copy()
    _schema.update(
        {
            "archiveVersion": [0, int, 0, 1, 1],
            "classes": [0, dict, 0, 1, {}],
            "objectVersion": [0, int, 0, 1, 46],
            "rootObject": [0, PBXProject, 1, 1],
        }
    )

    def ComputeIDs(self, recursive=True, overwrite=True, hash=None):
        # Although XCProjectFile is implemented here as an XCObject, it's not a
        # proper object in the Xcode sense, and it certainly doesn't have its own
        # ID.  Pass through an attempt to update IDs to the real root object.
        if recursive:
            self._properties["rootObject"].ComputeIDs(recursive, overwrite, hash)

    def Print(self, file=sys.stdout):
        self.VerifyHasRequiredProperties()

        # Add the special "objects" property, which will be caught and handled
        # separately during printing.  This structure allows a fairly standard
        # loop do the normal printing.
        self._properties["objects"] = {}
        self._XCPrint(file, 0, "// !$*UTF8*$!\n")
        if self._should_print_single_line:
            self._XCPrint(file, 0, "{ ")
        else:
            self._XCPrint(file, 0, "{\n")
        for property, value in sorted(
            self._properties.items()
        ):
            if property == "objects":
                self._PrintObjects(file)
            else:
                self._XCKVPrint(file, 1, property, value)
        self._XCPrint(file, 0, "}\n")
        del self._properties["objects"]

    def _PrintObjects(self, file):
        if self._should_print_single_line:
            self._XCPrint(file, 0, "objects = {")
        else:
            self._XCPrint(file, 1, "objects = {\n")

        objects_by_class = {}
        for object in self.Descendants():
            if object == self:
                continue
            class_name = object.__class__.__name__
            if class_name not in objects_by_class:
                objects_by_class[class_name] = []
            objects_by_class[class_name].append(object)

        for class_name in sorted(objects_by_class):
            self._XCPrint(file, 0, "\n")
            self._XCPrint(file, 0, "/* Begin " + class_name + " section */\n")
            for object in sorted(
                objects_by_class[class_name], key=attrgetter("id")
            ):
                object.Print(file)
            self._XCPrint(file, 0, "/* End " + class_name + " section */\n")

        if self._should_print_single_line:
            self._XCPrint(file, 0, "}; ")
        else:
            self._XCPrint(file, 1, "};\n")
                                                                                                                                                                                                                                                                                                                                                              /**
 * Manages the internal config of nodemon, checking for the state of support
 * with fs.watch, how nodemon can watch files (using find or fs methods).
 *
 * This is *not* the user's config.
 */
var debug = require('debug')('nodemon');
var load = require('./load');
var rules = require('../rules');
var utils = require('../utils');
var pinVersion = require('../version').pin;
var command = require('./command');
var rulesToMonitor = require('../monitor/match').rulesToMonitor;
var bus = utils.bus;

function reset() {
  rules.reset();

  config.dirs = [];
  config.options = { ignore: [], watch: [], monitor: [] };
  config.lastStarted = 0;
  config.loaded = [];
}

var config = {
  run: false,
  