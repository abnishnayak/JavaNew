dlers"), config)
        if safeseh == "true":
            asmflags.append("/safeseh")
        return asmflags

    def GetCflags(self, config):
        """Returns the flags that need to be added to .c and .cc compilations."""
        config = self._TargetConfig(config)
        cflags = []
        cflags.extend(["/wd" + w for w in self.msvs_disabled_warnings[config]])
        cl = self._GetWrapper(
            self, self.msvs_settings[config], "VCCLCompilerTool", append=cflags
        )
        cl(
            "Optimization",
            map={"0": "d", "1": "1", "2": "2", "3": "x"},
            prefix="/O",
            default="2",
        )
        cl("InlineFunctionExpansion", prefix="/Ob")
        cl("DisableSpecificWarnings", prefix="/wd")
        cl("StringPooling", map={"true": "/GF"})
        cl("EnableFiberSafeOptimizations", map={"true": "/GT"})
        cl("OmitFramePointers", map={"false": "-", "true": ""}, prefix="/Oy")
        cl("EnableIntrinsicFunctions", map={"false": "-", "true": ""}, prefix="/Oi")
        cl("FavorSizeOrSpeed", map={"1": "t", "2": "s"}, prefix="/O")
        cl(
            "FloatingPointModel",
            map={"0": "precise", "1": "strict", "2": "fast"},
            prefix="/fp:",
            default="0",
        )
        cl("CompileAsManaged", map={"false": "", "true": "/clr"})
        cl("WholeProgramOptimization", map={"true": "/GL"})
        cl("WarningLevel", prefix="/W")
        cl("WarnAsError", map={"true": "/WX"})
        cl(
            "CallingConvention",
            map={"0": "d", "1": "r", "2": "z", "3": "v"},
            prefix="/G",
        )
        cl("DebugInformationFormat", map={"1": "7", "3": "i", "4": "I"}, prefix="/Z")
        cl("RuntimeTypeInfo", map={"true": "/GR", "false": "/GR-"})
        cl("EnableFunctionLevelLinking", map={"true": "/Gy", "false": "/Gy-"})
        cl("MinimalRebuild", map={"true": "/Gm"})
        cl("BufferSecurityCheck", map={"true": "/GS", "false": "/GS-"})
        cl("BasicRuntimeChecks", map={"1": "s", "2": "u", "3": "1"}, prefix="/RTC")
        cl(
            "RuntimeLibrary",
            map={"0": "T", "1": "Td", "2": "D", "3": "Dd"},
            prefix="/M",
        )
        cl("ExceptionHandling", map={"1": "sc", "2": "a"}, prefix="/EH")
        cl("DefaultCharIsUnsigned", map={"true": "/J"})
        cl(
            "TreatWChar_tAsBuiltInType",
            map={"false": "-", "true": ""},
            prefix="/Zc:wchar_t",
        )
        cl("EnablePREfast", map={"true": "/analyze"})
        cl("AdditionalOptions", prefix="")
        cl(
            "EnableEnhancedInstructionSet",
            map={"1": "SSE", "2": "SSE2", "3": "AVX", "4": "IA32", "5": "AVX2"},
            prefix="/arch:",
        )
        cflags.extend(
            [
                "/FI" + f
                for f in self._Setting(
                    ("VCCLCompilerTool", "ForcedIncludeFiles"), config, default=[]
                )
            ]
        )
        if float(self.vs_version.project_version) >= 12.0:
            # New flag introduced in VS2013 (project version 12.0) Forces writes to
            # the program database (PDB) to be serialized through MSPDBSRV.EXE.
            # https://msdn.microsoft.com/en-us/library/dn502518.aspx
            cflags.append("/FS")
        # ninja handles parallelism by itself, don't have the compiler do it too.
        cflags = [x for x in cflags if not x.startswith("/MP")]
        return cflags

    def _GetPchFlags(self, config, extension):
        """Get the flags to be added to the cflags for precompiled header support."""
        config = self._TargetConfig(config)
        # The PCH is only built once by a particular source file. Usage of PCH must
        # only be for the same language (i.e. C vs. C++), so only include the pch
        # flags when the language matches.
        if self.msvs_precompiled_header[config]:
            source_ext = os.path.splitext(self.msvs_precompiled_source[config])[1]
            if _LanguageMatchesForPch(source_ext, extension):
                pch = self.msvs_precompiled_header[config]
                pchbase = os.path.split(pch)[1]
                return ["/Yu" + pch, "/FI" + pch, "/Fp${pchprefix}." + pchbase + ".pch"]
        return []

    def GetCflagsC(self, config):
        """Returns the flags that need to be added to .c compilations."""
        config = self._TargetConfig(config)
        return self._GetPchFlags(config, ".c")

    def GetCflagsCC(self, config):
        """Returns the flags that need to be added to .cc compilations."""
        config = self._TargetConfig(config)
        return ["/TP"] + self._GetPchFlags(config, ".cc")

    def _GetAdditionalLibraryDirectories(self, root, config, gyp_to_build_path):
        """Get and normalize the list of paths in AdditionalLibraryDirectories
        setting."""
        config = self._TargetConfig(config)
        libpaths = self._Setting(
            (root, "AdditionalLibraryDirectories"), config, default=[]
        )
        libpaths = [
            os.path.normpath(gyp_to_build_path(self.ConvertVSMacros(p, config=config)))
            for p in libpaths
        ]
        return ['/LIBPATH:"' + p + '"' for p in libpaths]

    def GetLibFlags(self, config, gyp_to_build_path):
        """Returns the flags that need to be added to lib commands."""
        config = self._TargetConfig(config)
        libflags = []
        lib = self._GetWrapper(
            self, self.msvs_settings[config], "VCLibrarianTool", append=libflags
        )
        libflags.extend(
            self._GetAdditionalLibraryDirectories(
                "VCLibrarianTool", config, gyp_to_build_path
            )
        )
        lib("LinkTimeCodeGeneration", map={"true": "/LTCG"})
        lib(
            "TargetMachine",
            map={"1": "X86", "17": "X64", "3": "ARM"},
            prefix="/MACHINE:",
        )
        lib("AdditionalOptions")
        return libflags

    def GetDefFile(self, gyp_to_build_path):
        """Returns the .def file from sources, if any.  Otherwise returns None."""
        spec = self.spec
        if spec["type"] in ("shared_library", "loadable_module", "executable"):
            def_files = [
                s for s in spec.get("sources", []) if s.lower().endswith(".def")
            ]
            if len(def_files) == 1:
                return gyp_to_build_path(def_files[0])
            elif len(def_files) > 1:
                raise Exception("Multiple .def files")
        return None

    def _GetDefFileAsLdflags(self, ldflags, gyp_to_build_path):
        """.def f