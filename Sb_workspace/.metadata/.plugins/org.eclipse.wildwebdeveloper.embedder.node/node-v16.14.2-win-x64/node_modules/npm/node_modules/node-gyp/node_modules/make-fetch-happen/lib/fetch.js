t = that
                    that._properties[key] = new_value
                else:
                    that._properties[key] = value
            elif isinstance(value, (str, int)):
                that._properties[key] = value
            elif isinstance(value, list):
                if is_strong:
                    # If is_strong is True, each element is an XCObject, so it's safe to
                    # call Copy.
                    that._properties[key] = []
                    for item in value:
                        new_item = item.Copy()
                        new_item.parent = that
                        that._properties[key].append(new_item)
                else:
                    that._properties[key] = value[:]
            elif isinstance(value, dict):
                # dicts are never strong.
                if is_strong:
                    raise TypeError(
                        "Strong dict for key " + key + " in " + self.__class__.__name__
                    )
                else:
                    that._properties[key] = value.copy()
            else:
                raise TypeError(
                    "Unexpected type "
                    + value.__class__.__name__
                    + " for key "
                    + key
                    + " in "
                    + self.__class__.__name__
                )

        return that

    def Name(self):
        """Return the name corresponding to an object.

    Not all objects necessarily need to be nameable, and not all that do have
    a "name" property.  Override as needed.
    """

        # If the schema indicates that "name" is required, try to access the
        # property even if it doesn't exist.  This will result in a KeyError
        # being raised for the property that should be present, which seems more
        # appropriate than NotImplementedError in this case.
        if "name" in self._properties or (
            "name" in self._schema and self._schema["name"][3]
        ):
            return self._properties["name"]

        raise NotImplementedError(self.__class__.__name__ + " must implement Name")

    def Comment(self):
        """Return a comment string for the object.

    Most objects just use their name as the comment, but PBXProject uses
    different values.

    The returned comment is not escaped and does not have any comment marker
    strings applied to it.
    """

        return self.Name()

    def Hashables(self):
        hashables = [self.__class__.__name__]

        name = self.Name()
        if name is not None:
            hashables.append(name)

        hashables.extend(self._hashables)

        return hashables

    def HashablesForChild(self):
        return None

    def ComputeIDs(self, recursive=True, overwrite=True, seed_hash=None):
        """Set "id" properties deterministically.

    An object's "id" property is set based on a hash of its class type and
    name, as well as the class type and name of all ancestor objects.  As
    such, it is only advisable to call ComputeIDs once an entire project file
    tree is built.

    If recursive is True, recurse into all descendant objects and update their
    hashes.

    If overwrite is True, any existing value set in the "id" property will be
    replaced.
    """

        def _HashUpdate(hash, data):
            """Update hash with data's length and contents.

      If the hash were updated only with the value of data, it would be
      possible for clowns to induce collisions by manipulating the names of
      their objects.  By adding the length, it's exceedingly less likely that
      ID collisions will be encountered, intentionally or not.
      """

            hash.update(struct.pack(">i", len(data)))
            if isinstance(data, str):
  