 exclusiveSet)
                if (keys.has(key))
                    used.push(key);
            if (used.length > 1)
                return pushError(state, `Mutually exclusive properties ${used.map(name => `"${name}"`).join(`, `)}`);
            return true;
        },
    });
};
(function (KeyRelationship) {
    KeyRelationship["Forbids"] = "Forbids";
    KeyRelationship["Requires"] = "Requires";
})(exports.KeyRelationship || (exports.KeyRelationship = {}));
const keyRelationships = {
    [exports.KeyRelationship.Forbids]: {
        expect: false,
        message: `forbids using`,
    },
    [exports.KeyRelationship.Requires]: {
        expect: true,
        message: `requires using`,
    },
};
const hasKeyRelationship = (subject, relationship, others, { ignore = [], } = {}) => {
    const skipped = new Set(ignore);
    const otherSet = new Set(others);
    const spec = keyRelationships[relationship];
    return makeValidator({
        test: (value, state) => {
            const keys = new Set(Object.keys(value));
            if (!keys.has(subject) || skipped.has(value[subject]))
                return true;
            const problems = [];
            for (const key of otherSet)
                if ((keys.has(key) && !skipped.has(value[key])) !== spec.expect)
                    problems.push(key);
            if (problems.length >= 1)
                return pushError(state, `Property "${subject}" ${spec.message} ${plural(problems.length, `property`, `properties`)} ${problems.map(name => `"${name}"`).join(`, `)}`);
            return true;
        },
    });
};

exports.applyCascade = applyCascade;
exports.base64RegExp = base64RegExp;
exports.colorStringAlphaRegExp = colorStringAlphaRegExp;
exports.colorStringRegExp = colorStringRegExp;
exports.computeKey = computeKey;
exports.getPrintable = getPrintable;
exports.hasE